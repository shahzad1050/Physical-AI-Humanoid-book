"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[1406],{7934:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module4/balance-control","title":"Balance and Postural Control","description":"Introduction to Balance and Postural Control","source":"@site/docs/module4/balance-control.md","sourceDirName":"module4","slug":"/module4/balance-control","permalink":"/Physical-AI-Humanoid-book/docs/module4/balance-control","draft":false,"unlisted":false,"editUrl":"https://github.com/user/physical-ai-humanoid-robotics/tree/main/docs/module4/balance-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Sim-to-Real Transfer Techniques","permalink":"/Physical-AI-Humanoid-book/docs/module3/sim-to-real"},"next":{"title":"Bipedal Locomotion","permalink":"/Physical-AI-Humanoid-book/docs/module4/bipedal-locomotion"}}');var r=t(4848),a=t(8453);const s={},i="Balance and Postural Control",l={},c=[{value:"Introduction to Balance and Postural Control",id:"introduction-to-balance-and-postural-control",level:2},{value:"Fundamentals of Postural Control",id:"fundamentals-of-postural-control",level:2},{value:"Postural Control System Components",id:"postural-control-system-components",level:3},{value:"Balance Control Strategies",id:"balance-control-strategies",level:3},{value:"State Estimation for Balance",id:"state-estimation-for-balance",level:2},{value:"Center of Mass (CoM) Estimation",id:"center-of-mass-com-estimation",level:3},{value:"State Estimation with Sensor Fusion",id:"state-estimation-with-sensor-fusion",level:3},{value:"Balance Control Algorithms",id:"balance-control-algorithms",level:2},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Cart-Table Model",id:"cart-table-model",level:3},{value:"Multi-Strategy Balance Control",id:"multi-strategy-balance-control",level:2},{value:"Hierarchical Balance Control",id:"hierarchical-balance-control",level:3},{value:"Advanced Balance Techniques",id:"advanced-balance-techniques",level:2},{value:"Model Predictive Control (MPC) for Balance",id:"model-predictive-control-mpc-for-balance",level:3},{value:"Compliance and Impedance Control",id:"compliance-and-impedance-control",level:3},{value:"Balance Recovery and Disturbance Handling",id:"balance-recovery-and-disturbance-handling",level:2},{value:"Disturbance Observer",id:"disturbance-observer",level:3},{value:"Balance Recovery Planning",id:"balance-recovery-planning",level:3},{value:"Implementation Example: Integrated Balance Controller",id:"implementation-example-integrated-balance-controller",level:2},{value:"Simulation and Testing",id:"simulation-and-testing",level:2},{value:"Balance Control Testing Framework",id:"balance-control-testing-framework",level:3},{value:"Summary",id:"summary",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"balance-and-postural-control",children:"Balance and Postural Control"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-balance-and-postural-control",children:"Introduction to Balance and Postural Control"}),"\n",(0,r.jsx)(n.p,{children:"Balance and postural control are fundamental capabilities for humanoid robots, enabling them to maintain stability while performing various tasks. Unlike wheeled or tracked robots, humanoid robots must actively control their posture to maintain balance, especially during dynamic movements like walking, running, or manipulation tasks."}),"\n",(0,r.jsx)(n.h2,{id:"fundamentals-of-postural-control",children:"Fundamentals of Postural Control"}),"\n",(0,r.jsx)(n.h3,{id:"postural-control-system-components",children:"Postural Control System Components"}),"\n",(0,r.jsx)(n.p,{children:"The postural control system in humanoid robots typically consists of three main components:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensors"}),": IMU, force/torque sensors, joint encoders, vision systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Estimation"}),": Estimating robot pose, velocity, and external disturbances"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Control Algorithms"}),": Generating appropriate motor commands to maintain balance"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"balance-control-strategies",children:"Balance Control Strategies"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots employ several balance control strategies:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ankle Strategy"}),": Adjusting ankle torques to maintain balance (for small disturbances)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hip Strategy"}),": Using hip movements to control balance (for medium disturbances)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stepping Strategy"}),": Taking a step to recover balance (for large disturbances)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Arm Strategy"}),": Using arm movements to assist balance"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"state-estimation-for-balance",children:"State Estimation for Balance"}),"\n",(0,r.jsx)(n.h3,{id:"center-of-mass-com-estimation",children:"Center of Mass (CoM) Estimation"}),"\n",(0,r.jsx)(n.p,{children:"Accurate CoM estimation is crucial for balance control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass CenterOfMassEstimator:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.link_masses = robot_model.link_masses\n        self.link_poses = {}\n\n    def estimate_com_position(self, joint_angles):\n        """\n        Estimate Center of Mass position from joint angles\n        """\n        total_mass = sum(self.link_masses.values())\n\n        com_numerator = np.zeros(3)\n\n        # Calculate transforms for each link\n        transforms = self.calculate_link_transforms(joint_angles)\n\n        for link_name, mass in self.link_masses.items():\n            if link_name in transforms:\n                # Get link CoM position in world frame\n                link_transform = transforms[link_name]\n                local_com = self.model.get_link_com_offset(link_name)\n\n                # Transform local CoM to world frame\n                world_com = link_transform[:3, :3] @ local_com + link_transform[:3, 3]\n\n                com_numerator += mass * world_com\n\n        com_position = com_numerator / total_mass\n        return com_position\n\n    def estimate_com_velocity(self, joint_angles, joint_velocities):\n        """\n        Estimate CoM velocity using Jacobian method\n        """\n        J_com = self.calculate_com_jacobian(joint_angles)\n        com_velocity = J_com @ joint_velocities\n        return com_velocity\n\n    def estimate_com_acceleration(self, joint_angles, joint_velocities, joint_accelerations):\n        """\n        Estimate CoM acceleration\n        """\n        J_com = self.calculate_com_jacobian(joint_angles)\n        J_com_dot = self.calculate_com_jacobian_derivative(joint_angles, joint_velocities)\n\n        com_acceleration = J_com @ joint_accelerations + J_com_dot @ joint_velocities\n        return com_acceleration\n\n    def calculate_link_transforms(self, joint_angles):\n        """\n        Calculate transforms for all links\n        """\n        transforms = {}\n\n        # This would use forward kinematics to calculate all link transforms\n        # Implementation depends on robot kinematic structure\n        for link_name in self.model.link_names:\n            transform = self.model.forward_kinematics(joint_angles, link_name)\n            transforms[link_name] = transform\n\n        return transforms\n\n    def calculate_com_jacobian(self, joint_angles):\n        """\n        Calculate Jacobian matrix for CoM\n        """\n        n_joints = len(joint_angles)\n        J_com = np.zeros((3, n_joints))\n\n        # Calculate CoM Jacobian using individual link contributions\n        total_mass = sum(self.link_masses.values())\n\n        transforms = self.calculate_link_transforms(joint_angles)\n\n        for i, (link_name, mass) in enumerate(self.link_masses.items()):\n            if link_name in transforms:\n                # Get link Jacobian\n                J_link = self.model.get_link_jacobian(joint_angles, link_name)\n\n                # Weight by mass ratio\n                J_com += (mass / total_mass) * J_link[:3, :]  # Only position part\n\n        return J_com\n\n    def calculate_com_jacobian_derivative(self, joint_angles, joint_velocities):\n        """\n        Calculate time derivative of CoM Jacobian\n        """\n        # This is a simplified approximation\n        # Full implementation would require more complex calculations\n        n_joints = len(joint_angles)\n        J_com_dot = np.zeros((3, n_joints))\n\n        # Approximate using finite differences\n        h = 1e-6\n        J_plus = self.calculate_com_jacobian(joint_angles + h * joint_velocities)\n        J_minus = self.calculate_com_jacobian(joint_angles - h * joint_velocities)\n\n        J_com_dot = (J_plus - J_minus) / (2 * h)\n\n        return J_com_dot\n'})}),"\n",(0,r.jsx)(n.h3,{id:"state-estimation-with-sensor-fusion",children:"State Estimation with Sensor Fusion"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class StateEstimator:\n    def __init__(self, dt=0.01):\n        self.dt = dt\n        self.state = np.zeros(13)  # [pos(3), quat(4), vel(3), omega(3)]\n        self.covariance = np.eye(13) * 0.1\n        self.gravity = np.array([0, 0, -9.81])\n\n        # Process noise\n        self.Q = np.diag([0.1, 0.1, 0.1, 0.01, 0.01, 0.01, 0.01, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n\n        # Measurement noise\n        self.R_imu = np.diag([0.01, 0.01, 0.01, 0.001, 0.001, 0.001])  # acc, gyro\n        self.R_foot = np.diag([0.001, 0.001, 0.001])  # position\n\n    def predict(self, control_input):\n        """\n        Prediction step of EKF\n        """\n        # Extract state variables\n        pos = self.state[0:3]\n        quat = self.state[3:7]  # [w, x, y, z]\n        vel = self.state[7:10]\n        omega = self.state[10:13]  # Angular velocity\n\n        # Normalize quaternion\n        quat = quat / np.linalg.norm(quat)\n\n        # Convert angular velocity to quaternion derivative\n        omega_quat = np.array([0, omega[0], omega[1], omega[2]])\n        quat_dot = 0.5 * self.quaternion_multiply(quat, omega_quat)\n\n        # State transition model\n        new_pos = pos + vel * self.dt\n        new_quat = quat + quat_dot * self.dt\n        new_quat = new_quat / np.linalg.norm(new_quat)  # Renormalize\n\n        # Acceleration from control and gravity\n        linear_acc = control_input[\'linear_acc\'] if \'linear_acc\' in control_input else np.zeros(3)\n        new_vel = vel + (linear_acc + self.gravity) * self.dt\n        new_omega = omega + control_input.get(\'angular_acc\', np.zeros(3)) * self.dt\n\n        # Update state\n        self.state = np.hstack([new_pos, new_quat, new_vel, new_omega])\n\n        # Update covariance (simplified)\n        F = self.calculate_jacobian()\n        self.covariance = F @ self.covariance @ F.T + self.Q\n\n    def update_with_imu(self, measured_acc, measured_gyro):\n        """\n        Update state estimate with IMU measurements\n        """\n        # Predicted measurements\n        quat = self.state[3:7]\n        R_world_imu = self.quaternion_to_rotation_matrix(quat)\n\n        # Predicted acceleration (in world frame)\n        linear_acc_world = self.state[7:10]  # Linear acceleration\n        predicted_acc = R_world_imu.T @ (linear_acc_world - self.gravity)\n\n        # Predicted angular velocity\n        predicted_gyro = self.state[10:13]\n\n        predicted_measurement = np.hstack([predicted_acc, predicted_gyro])\n        measured_measurement = np.hstack([measured_acc, measured_gyro])\n\n        # Innovation\n        innovation = measured_measurement - predicted_measurement\n\n        # Measurement matrix\n        H = self.get_imu_measurement_matrix()\n\n        # Innovation covariance\n        S = H @ self.covariance @ H.T + self.R_imu\n\n        # Kalman gain\n        K = self.covariance @ H.T @ np.linalg.inv(S)\n\n        # Update state\n        self.state = self.state + K @ innovation\n\n        # Update covariance\n        I = np.eye(len(self.state))\n        self.covariance = (I - K @ H) @ self.covariance\n\n    def update_with_foot_contact(self, foot_position, is_left_foot=True):\n        """\n        Update state estimate with foot contact information\n        """\n        # Foot position should be at ground level (z=0) when in contact\n        if is_left_foot:\n            predicted_foot_pos = self.get_left_foot_position()\n        else:\n            predicted_foot_pos = self.get_right_foot_position()\n\n        # Measurement residual\n        residual = foot_position - predicted_foot_pos\n\n        # Simplified update - only correct position part\n        self.state[0:3] = self.state[0:3] + 0.1 * residual  # Simple correction\n\n    def get_left_foot_position(self):\n        """\n        Get left foot position from current state\n        """\n        # This would use forward kinematics with current joint angles\n        # Simplified as an example\n        return self.state[0:3] + np.array([0, 0.1, -0.8])  # Approximate\n\n    def get_right_foot_position(self):\n        """\n        Get right foot position from current state\n        """\n        # Simplified as an example\n        return self.state[0:3] + np.array([0, -0.1, -0.8])  # Approximate\n\n    def quaternion_multiply(self, q1, q2):\n        """\n        Multiply two quaternions\n        """\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n\n        w = w1*w2 - x1*x2 - y1*y2 - z1*z2\n        x = w1*x2 + x1*w2 + y1*z2 - z1*y2\n        y = w1*y2 - x1*z2 + y1*w2 + z1*x2\n        z = w1*z2 + x1*y2 - y1*x2 + z1*w2\n\n        return np.array([w, x, y, z])\n\n    def quaternion_to_rotation_matrix(self, quat):\n        """\n        Convert quaternion to rotation matrix\n        """\n        w, x, y, z = quat\n\n        R = np.array([\n            [1 - 2*(y**2 + z**2), 2*(x*y - w*z), 2*(x*z + w*y)],\n            [2*(x*y + w*z), 1 - 2*(x**2 + z**2), 2*(y*z - w*x)],\n            [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x**2 + y**2)]\n        ])\n\n        return R\n\n    def calculate_jacobian(self):\n        """\n        Calculate state transition Jacobian\n        """\n        # Simplified Jacobian matrix\n        F = np.eye(13)\n\n        # Position with respect to velocity\n        F[0:3, 7:10] = np.eye(3) * self.dt\n\n        # Velocity with respect to acceleration\n        F[7:10, 7:10] = np.eye(3)  # Basic integration\n\n        # Quaternion with respect to angular velocity (simplified)\n        F[3:7, 10:13] = 0.5 * self.dt  # Very simplified\n\n        return F\n\n    def get_imu_measurement_matrix(self):\n        """\n        Get measurement matrix for IMU\n        """\n        # Simplified - maps state to IMU measurements\n        H = np.zeros((6, 13))\n\n        # Accelerometer measures linear acceleration + gravity\n        H[0:3, 7:10] = np.eye(3)  # Linear acceleration affects accelerometer\n\n        # Gyroscope measures angular velocity\n        H[3:6, 10:13] = np.eye(3)  # Angular velocity affects gyroscope\n\n        return H\n'})}),"\n",(0,r.jsx)(n.h2,{id:"balance-control-algorithms",children:"Balance Control Algorithms"}),"\n",(0,r.jsx)(n.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,r.jsx)(n.p,{children:"The Linear Inverted Pendulum Model is widely used for balance control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class LIPMController:\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.h = com_height  # CoM height\n        self.g = gravity\n        self.omega = np.sqrt(self.g / self.h)\n\n        # Control gains\n        self.K_pos = 10.0\n        self.K_vel = 2.0 * np.sqrt(10.0)  # Critical damping\n\n    def calculate_zmp_from_com(self, com_pos, com_vel):\n        """\n        Calculate ZMP from CoM state using LIPM\n        """\n        # ZMP = CoM - (h/g) * CoM_acceleration\n        # For LIPM: CoM_acceleration = omega^2 * (CoM - ZMP)\n        # So: ZMP = CoM - (1/omega^2) * CoM_acceleration\n        # But we need a control law to determine CoM_acceleration\n\n        # Simplified control law: ZMP = reference + Kp*pos_error + Kd*vel_error\n        zmp_ref = np.array([0.0, 0.0])  # Reference ZMP (typically under feet center)\n\n        pos_error = com_pos[:2] - zmp_ref\n        vel_error = com_vel[:2]\n\n        zmp_cmd = zmp_ref + self.K_pos * pos_error + self.K_vel * vel_error\n\n        return zmp_cmd\n\n    def calculate_com_reference(self, zmp_ref, current_com, current_com_vel, dt=0.01):\n        """\n        Calculate CoM reference trajectory from ZMP reference\n        """\n        # Inverted dynamics: CoM_ddot = g/h * (CoM - ZMP)\n        com_acc_ref = (self.g / self.h) * (current_com[:2] - zmp_ref)\n\n        # Integrate to get velocity and position references\n        com_vel_ref = current_com_vel[:2] + com_acc_ref * dt\n        com_pos_ref = current_com[:2] + com_vel_ref * dt\n\n        return com_pos_ref, com_vel_ref, com_acc_ref\n\n    def generate_balance_trajectory(self, current_state, target_zmp, duration=1.0, dt=0.01):\n        """\n        Generate balance recovery trajectory\n        """\n        timesteps = int(duration / dt)\n\n        com_trajectory = np.zeros((timesteps, 3))\n        com_velocity = np.zeros((timesteps, 3))\n        com_acceleration = np.zeros((timesteps, 3))\n\n        current_com = current_state[\'com_pos\']\n        current_com_vel = current_state[\'com_vel\']\n\n        for i in range(timesteps):\n            t = i * dt\n\n            # Interpolate ZMP reference\n            alpha = t / duration\n            current_zmp_ref = alpha * target_zmp + (1 - alpha) * current_state[\'current_zmp\'][:2]\n\n            # Calculate CoM reference\n            com_pos_ref, com_vel_ref, com_acc_ref = self.calculate_com_reference(\n                current_zmp_ref, current_com, current_com_vel, dt\n            )\n\n            # Update for next iteration\n            current_com[:2] = com_pos_ref\n            current_com_vel[:2] = com_vel_ref\n\n            com_trajectory[i, :2] = com_pos_ref\n            com_velocity[i, :2] = com_vel_ref\n            com_acceleration[i, :2] = com_acc_ref\n\n            # Maintain height\n            com_trajectory[i, 2] = self.h\n            com_velocity[i, 2] = 0\n            com_acceleration[i, 2] = 0\n\n        return com_trajectory, com_velocity, com_acceleration\n\n    def calculate_capture_point(self, com_pos, com_vel):\n        """\n        Calculate capture point - where to step to stop the CoM\n        """\n        capture_point = com_pos[:2] + com_vel[:2] / self.omega\n        return capture_point\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cart-table-model",children:"Cart-Table Model"}),"\n",(0,r.jsx)(n.p,{children:"The Cart-Table model is another approach for balance control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class CartTableController:\n    def __init__(self, com_height=0.8, gravity=9.81, cart_mass=1.0):\n        self.h = com_height\n        self.g = gravity\n        self.m = cart_mass  # Effective mass of CoM\n        self.omega = np.sqrt(self.g / self.h)\n\n        # Control gains\n        self.Kp_com = np.diag([100, 100])  # CoM position\n        self.Kd_com = np.diag([20, 20])    # CoM velocity\n        self.Kp_foot = np.diag([50, 50])   # Foot position\n        self.Kd_foot = np.diag([10, 10])   # Foot velocity\n\n    def compute_cart_table_control(self, current_state, desired_state):\n        \"\"\"\n        Compute control using Cart-Table model\n        \"\"\"\n        # Current state\n        com_pos = current_state['com_pos'][:2]\n        com_vel = current_state['com_vel'][:2]\n        foot_pos = current_state['foot_pos'][:2]\n        foot_vel = current_state['foot_vel'][:2]\n\n        # Desired state\n        des_com_pos = desired_state['com_pos'][:2]\n        des_com_vel = desired_state['com_vel'][:2]\n        des_foot_pos = desired_state['foot_pos'][:2]\n        des_foot_vel = desired_state['foot_vel'][:2]\n\n        # Position and velocity errors\n        com_pos_error = des_com_pos - com_pos\n        com_vel_error = des_com_vel - com_vel\n        foot_pos_error = des_foot_pos - foot_pos\n        foot_vel_error = des_foot_vel - foot_vel\n\n        # Control law: F = Kp*pos_error + Kd*vel_error\n        com_control = self.Kp_com @ com_pos_error + self.Kd_com @ com_vel_error\n        foot_control = self.Kp_foot @ foot_pos_error + self.Kd_foot @ foot_vel_error\n\n        # Combine controls\n        total_control = com_control + foot_control\n\n        return total_control\n"})}),"\n",(0,r.jsx)(n.h2,{id:"multi-strategy-balance-control",children:"Multi-Strategy Balance Control"}),"\n",(0,r.jsx)(n.h3,{id:"hierarchical-balance-control",children:"Hierarchical Balance Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class HierarchicalBalanceController:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.lipm_controller = LIPMController(com_height=0.8)\n        self.state_estimator = StateEstimator()\n        self.footstep_planner = FootstepPlanner()\n\n        # Balance strategy thresholds\n        self.ankle_threshold = 0.05  # 5cm\n        self.hip_threshold = 0.15    # 15cm\n        self.step_threshold = 0.3    # 30cm\n\n        # Current strategy\n        self.current_strategy = "ankle"\n        self.support_foot = "left"  # Current support foot\n\n    def select_balance_strategy(self, current_state):\n        """\n        Select appropriate balance strategy based on disturbance magnitude\n        """\n        com_pos = current_state[\'com_pos\']\n        zmp_pos = current_state[\'zmp_pos\']\n        support_polygon = current_state[\'support_polygon\']\n\n        # Calculate distance from ZMP to support polygon boundary\n        zmp_x, zmp_y = zmp_pos[0], zmp_pos[1]\n\n        dist_to_boundary_x = min(\n            abs(zmp_x - support_polygon[\'min_x\']),\n            abs(zmp_x - support_polygon[\'max_x\'])\n        )\n\n        dist_to_boundary_y = min(\n            abs(zmp_y - support_polygon[\'min_y\']),\n            abs(zmp_y - support_polygon[\'max_y\'])\n        )\n\n        min_dist_to_boundary = min(dist_to_boundary_x, dist_to_boundary_y)\n\n        # Select strategy based on distance\n        if min_dist_to_boundary > self.step_threshold:\n            strategy = "ankle"  # Small disturbance\n        elif min_dist_to_boundary > self.hip_threshold:\n            strategy = "hip"    # Medium disturbance\n        elif min_dist_to_boundary > self.ankle_threshold:\n            strategy = "step"   # Large disturbance - prepare to step\n        else:\n            strategy = "emergency"  # Very large disturbance\n\n        return strategy\n\n    def execute_balance_strategy(self, strategy, current_state):\n        """\n        Execute the selected balance strategy\n        """\n        if strategy == "ankle":\n            return self.ankle_strategy(current_state)\n        elif strategy == "hip":\n            return self.hip_strategy(current_state)\n        elif strategy == "step":\n            return self.step_strategy(current_state)\n        elif strategy == "emergency":\n            return self.emergency_strategy(current_state)\n        else:\n            return self.ankle_strategy(current_state)  # Default\n\n    def ankle_strategy(self, current_state):\n        """\n        Ankle strategy: adjust ankle torques to maintain balance\n        """\n        # Calculate desired CoM position based on ZMP control\n        com_pos = current_state[\'com_pos\']\n        com_vel = current_state[\'com_vel\']\n\n        # Use LIPM to calculate required ZMP\n        desired_zmp = self.lipm_controller.calculate_zmp_from_com(com_pos, com_vel)\n\n        # Convert ZMP to ankle torques\n        ankle_torques = self.zmp_to_ankle_torques(desired_zmp, current_state)\n\n        return {\n            \'joint_torques\': self.distribute_ankle_torques(ankle_torques),\n            \'strategy\': \'ankle\',\n            \'zmp_ref\': desired_zmp\n        }\n\n    def hip_strategy(self, current_state):\n        """\n        Hip strategy: use hip movements to control balance\n        """\n        # Calculate CoM control to move ZMP back to safe region\n        com_pos = current_state[\'com_pos\']\n        com_vel = current_state[\'com_vel\']\n\n        # Calculate capture point\n        capture_point = self.lipm_controller.calculate_capture_point(com_pos, com_vel)\n\n        # Generate CoM trajectory to move capture point toward safe area\n        safe_area_center = self.calculate_safe_area_center(current_state)\n\n        # Create trajectory to move CoM toward safe area\n        com_trajectory = self.generate_com_trajectory_to_safe_area(\n            com_pos, safe_area_center\n        )\n\n        # Calculate required joint torques\n        joint_torques = self.com_trajectory_to_joint_torques(com_trajectory, current_state)\n\n        return {\n            \'joint_torques\': joint_torques,\n            \'strategy\': \'hip\',\n            \'com_trajectory\': com_trajectory\n        }\n\n    def step_strategy(self, current_state):\n        """\n        Step strategy: plan and execute a step to recover balance\n        """\n        # Calculate capture point\n        com_pos = current_state[\'com_pos\']\n        com_vel = current_state[\'com_vel\']\n\n        capture_point = self.lipm_controller.calculate_capture_point(com_pos, com_vel)\n\n        # Plan step to capture point\n        next_support_foot_pos = self.plan_step_to_capture_point(\n            capture_point, current_state\n        )\n\n        # Generate foot trajectory\n        foot_trajectory = self.generate_foot_trajectory_to_point(\n            next_support_foot_pos, current_state\n        )\n\n        # Execute step while maintaining balance\n        control_commands = self.execute_step_with_balance(\n            foot_trajectory, current_state\n        )\n\n        # Update support foot\n        self.support_foot = "right" if self.support_foot == "left" else "left"\n\n        return {\n            \'joint_torques\': control_commands[\'joint_torques\'],\n            \'foot_trajectory\': foot_trajectory,\n            \'strategy\': \'step\',\n            \'next_support_foot\': self.support_foot\n        }\n\n    def emergency_strategy(self, current_state):\n        """\n        Emergency strategy: prepare for fall or extreme measures\n        """\n        # Safety measures: bend knees, extend arms, prepare for impact\n        emergency_torques = self.calculate_emergency_torques(current_state)\n\n        return {\n            \'joint_torques\': emergency_torques,\n            \'strategy\': \'emergency\',\n            \'safety_mode\': True\n        }\n\n    def zmp_to_ankle_torques(self, desired_zmp, current_state):\n        """\n        Convert ZMP command to ankle torques\n        """\n        # Simplified conversion - in practice, this involves more complex calculations\n        # relating ZMP deviation to required ankle torques\n        current_zmp = current_state[\'current_zmp\']\n\n        zmp_error = desired_zmp - current_zmp[:2]\n\n        # Proportional control to generate ankle torques\n        ankle_torque_x = 500 * zmp_error[0]  # N-m per m error\n        ankle_torque_y = 500 * zmp_error[1]  # N-m per m error\n\n        return np.array([ankle_torque_x, ankle_torque_y])\n\n    def distribute_ankle_torques(self, ankle_torques):\n        """\n        Distribute ankle torques to joint controllers\n        """\n        # This would convert ankle torques to individual joint torques\n        # based on robot kinematics and control allocation\n        n_joints = self.model.n_joints\n        joint_torques = np.zeros(n_joints)\n\n        # Simplified mapping - in practice, use full kinematic model\n        # Map ankle torques to ankle joint torques\n        ankle_indices = self.get_ankle_joint_indices()\n\n        for i, idx in enumerate(ankle_indices):\n            if i < len(ankle_torques):\n                joint_torques[idx] = ankle_torques[i]\n\n        return joint_torques\n\n    def get_ankle_joint_indices(self):\n        """\n        Get indices of ankle joints in the joint array\n        """\n        # This depends on the specific robot joint ordering\n        # Example: assuming ankle joints are at specific indices\n        return [10, 11, 24, 25]  # Example indices for left and right ankle\n\n    def calculate_safe_area_center(self, current_state):\n        """\n        Calculate center of safe area based on support polygon\n        """\n        support_polygon = current_state[\'support_polygon\']\n\n        safe_center_x = (support_polygon[\'min_x\'] + support_polygon[\'max_x\']) / 2\n        safe_center_y = (support_polygon[\'min_y\'] + support_polygon[\'max_y\']) / 2\n\n        return np.array([safe_center_x, safe_center_y, current_state[\'com_pos\'][2]])\n\n    def generate_com_trajectory_to_safe_area(self, current_com, safe_target):\n        """\n        Generate CoM trajectory to move toward safe area\n        """\n        # Use 5th order polynomial for smooth trajectory\n        duration = 0.5  # 500ms to reach safe area\n        dt = 0.01\n        steps = int(duration / dt)\n\n        trajectory = np.zeros((steps, 3))\n\n        for i in range(3):  # For each axis\n            start_pos = current_com[i]\n            end_pos = safe_target[i]\n\n            # 5th order polynomial coefficients\n            coeffs = self.calculate_5th_order_coefficients(\n                start_pos, 0, 0,  # start pos, vel, acc\n                end_pos, 0, 0     # end pos, vel, acc\n            )\n\n            for j in range(steps):\n                t = j * dt / duration  # normalized time [0, 1]\n                trajectory[j, i] = (\n                    coeffs[0] +\n                    coeffs[1] * t +\n                    coeffs[2] * t**2 +\n                    coeffs[3] * t**3 +\n                    coeffs[4] * t**4 +\n                    coeffs[5] * t**5\n                )\n\n        return trajectory\n\n    def calculate_5th_order_coefficients(self, x0, v0, a0, x1, v1, a1):\n        """\n        Calculate coefficients for 5th order polynomial\n        """\n        A = np.array([\n            [1, 0, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0, 0],\n            [0, 0, 2, 0, 0, 0],\n            [1, 1, 1, 1, 1, 1],\n            [0, 1, 2, 3, 4, 5],\n            [0, 0, 2, 6, 12, 20]\n        ])\n\n        b = np.array([x0, v0, a0, x1, v1, a1])\n        coeffs = np.linalg.solve(A, b)\n\n        return coeffs\n\n    def plan_step_to_capture_point(self, capture_point, current_state):\n        """\n        Plan step location to capture point\n        """\n        current_pos = current_state[\'base_pos\'][:2]\n\n        # Calculate step direction and distance\n        step_vector = capture_point - current_pos\n        step_distance = np.linalg.norm(step_vector)\n\n        if step_distance > 0:\n            step_direction = step_vector / step_distance\n            # Limit step size to maximum step length\n            max_step_length = 0.4  # 40cm maximum step\n            actual_step_length = min(step_distance, max_step_length)\n\n            target_pos = current_pos + actual_step_length * step_direction\n        else:\n            target_pos = current_pos\n\n        # Add small margin for stability\n        target_pos[2] = 0  # Ground level\n\n        return target_pos\n\n    def generate_foot_trajectory_to_point(self, target_pos, current_state):\n        """\n        Generate foot trajectory to step location\n        """\n        current_foot_pos = current_state[f\'{self.support_foot}_foot_pos\']\n\n        # Use polynomial trajectory\n        duration = 0.4  # 400ms for step\n        dt = 0.01\n        steps = int(duration / dt)\n\n        trajectory = np.zeros((steps, 6))  # Position and velocity for x, y, z\n\n        for i in range(3):  # x, y, z\n            if i < 2:  # Horizontal movement\n                start_pos = current_foot_pos[i]\n                end_pos = target_pos[i]\n            else:  # Vertical movement\n                start_pos = current_foot_pos[i]\n                end_pos = target_pos[i] if i == 2 else start_pos\n\n                # Add foot lift for step\n                if np.linalg.norm(target_pos[:2] - current_foot_pos[:2]) > 0.05:\n                    # Significant step - lift foot\n                    end_pos = current_foot_pos[i] + 0.1  # Lift 10cm\n\n            # Calculate trajectory\n            coeffs = self.calculate_5th_order_coefficients(\n                start_pos, 0, 0,  # start pos, vel, acc\n                end_pos, 0, 0     # end pos, vel, acc\n            )\n\n            for j in range(steps):\n                t = j * dt / duration\n                trajectory[j, i] = (\n                    coeffs[0] + coeffs[1]*t + coeffs[2]*t**2 +\n                    coeffs[3]*t**3 + coeffs[4]*t**4 + coeffs[5]*t**5\n                )\n\n        # Calculate velocities (derivatives)\n        for i in range(3):\n            for j in range(steps):\n                if j > 0:\n                    trajectory[j, i+3] = (trajectory[j, i] - trajectory[j-1, i]) / dt\n                else:\n                    trajectory[j, i+3] = 0  # Initial velocity\n\n        return trajectory\n\n    def execute_step_with_balance(self, foot_trajectory, current_state):\n        """\n        Execute step while maintaining balance\n        """\n        # This would coordinate the step with balance control\n        # For now, return a simplified control command\n        n_joints = self.model.n_joints\n        joint_torques = np.zeros(n_joints)\n\n        # Add balance torques while executing step\n        balance_torques = self.calculate_balance_torques(current_state)\n        step_torques = self.foot_trajectory_to_joint_torques(foot_trajectory[0])\n\n        # Combine torques\n        joint_torques = balance_torques + 0.5 * step_torques\n\n        return {\'joint_torques\': joint_torques}\n\n    def calculate_balance_torques(self, current_state):\n        """\n        Calculate torques for balance maintenance\n        """\n        # Use current balance strategy to calculate required torques\n        com_pos = current_state[\'com_pos\']\n        com_vel = current_state[\'com_vel\']\n\n        desired_zmp = self.lipm_controller.calculate_zmp_from_com(com_pos, com_vel)\n        ankle_torques = self.zmp_to_ankle_torques(desired_zmp, current_state)\n\n        return self.distribute_ankle_torques(ankle_torques)\n\n    def foot_trajectory_to_joint_torques(self, foot_state):\n        """\n        Convert desired foot state to joint torques\n        """\n        # This would use inverse dynamics or operational space control\n        n_joints = self.model.n_joints\n        return np.zeros(n_joints)  # Placeholder\n\n    def calculate_emergency_torques(self, current_state):\n        """\n        Calculate emergency safety torques\n        """\n        n_joints = self.model.n_joints\n        emergency_torques = np.zeros(n_joints)\n\n        # Example: bend knees to lower CoM, extend arms for protection\n        knee_indices = self.get_knee_joint_indices()\n        arm_indices = self.get_arm_joint_indices()\n\n        # Knee bending (flex joints)\n        for idx in knee_indices:\n            emergency_torques[idx] = 10  # Torque to flex knees\n\n        # Arm extension for protection\n        for idx in arm_indices:\n            emergency_torques[idx] = 5  # Protective arm positioning\n\n        return emergency_torques\n\n    def get_knee_joint_indices(self):\n        """\n        Get indices of knee joints\n        """\n        # Example indices - would depend on specific robot\n        return [8, 22]  # Left and right knee\n\n    def get_arm_joint_indices(self):\n        """\n        Get indices of arm joints\n        """\n        # Example indices - would depend on specific robot\n        return [2, 3, 4, 16, 17, 18]  # Both arm joints\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-balance-techniques",children:"Advanced Balance Techniques"}),"\n",(0,r.jsx)(n.h3,{id:"model-predictive-control-mpc-for-balance",children:"Model Predictive Control (MPC) for Balance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class MPCBalanceController:\n    def __init__(self, prediction_horizon=20, dt=0.01):\n        self.N = prediction_horizon  # Prediction horizon\n        self.dt = dt\n        self.Q = np.diag([100, 100, 10, 1, 1, 1])  # State cost (CoM pos/vel, ZMP)\n        self.R = np.diag([1, 1, 0.1, 0.1])         # Control cost (joint velocities/torques)\n        self.P = np.diag([500, 500, 50, 5, 5, 5])  # Terminal cost\n\n    def solve_balance_mpc(self, current_state, reference_trajectory):\n        """\n        Solve MPC problem for balance control\n        """\n        # This would typically use a QP solver like OSQP or CVXOPT\n        # For this example, we\'ll outline the structure\n\n        # System matrices for LIPM (Linear Inverted Pendulum Model)\n        A = self.get_system_matrix()\n        B = self.get_input_matrix()\n\n        # State: [com_x, com_y, com_x_dot, com_y_dot]\n        current_x = np.array([\n            current_state[\'com_pos\'][0],\n            current_state[\'com_pos\'][1],\n            current_state[\'com_vel\'][0],\n            current_state[\'com_vel\'][1]\n        ])\n\n        # Initialize optimization variables\n        X = np.zeros((4, self.N + 1))  # State trajectory\n        U = np.zeros((2, self.N))      # Control trajectory (ZMP commands)\n\n        X[:, 0] = current_x  # Initial state\n\n        # Prediction loop\n        for k in range(self.N):\n            # Predict next state: x_{k+1} = A*x_k + B*u_k\n            X[:, k+1] = A @ X[:, k] + B @ U[:, k]\n\n            # Compute control based on reference tracking\n            if k < len(reference_trajectory):\n                ref_state = reference_trajectory[k]\n            else:\n                ref_state = reference_trajectory[-1]  # Hold last reference\n\n            # Simple LQR control law (in practice, solve full QP)\n            U[:, k] = self.compute_lqr_control(X[:, k], ref_state)\n\n        # Return first control in sequence\n        return U[:, 0]\n\n    def get_system_matrix(self):\n        """\n        Get system matrix A for LIPM\n        """\n        # For LIPM: [\u1e8d] = \u03c9\xb2 * [x - zmp_x]\n        #          [\xff] = \u03c9\xb2 * [y - zmp_y]\n        # Discretized form\n        omega = 3.5  # Example value (sqrt(g/h))\n        dt = self.dt\n\n        A = np.array([\n            [1, 0, dt, 0],\n            [0, 1, 0, dt],\n            [omega**2 * dt, 0, 1, 0],\n            [0, omega**2 * dt, 0, 1]\n        ])\n\n        return A\n\n    def get_input_matrix(self):\n        """\n        Get input matrix B for LIPM\n        """\n        omega = 3.5\n        dt = self.dt\n\n        B = np.array([\n            [0, 0],\n            [0, 0],\n            [-omega**2 * dt, 0],\n            [0, -omega**2 * dt]\n        ])\n\n        return B\n\n    def compute_lqr_control(self, state, reference):\n        """\n        Compute LQR control law\n        """\n        # Solve Riccati equation offline, then apply feedback law\n        # For this example, use simple gains\n        Q = np.eye(4) * 10\n        R_inv = 1.0\n\n        # Approximate LQR gain\n        K = np.array([[1, 0, 2, 0], [0, 1, 0, 2]])  # [k_x, k_y, k_xdot, k_ydot] for each dim\n\n        error = reference[:4] - state\n        control = R_inv * K @ error\n\n        return control\n'})}),"\n",(0,r.jsx)(n.h3,{id:"compliance-and-impedance-control",children:"Compliance and Impedance Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ComplianceBalanceController:\n    def __init__(self, robot_model):\n        self.model = robot_model\n\n        # Impedance parameters for different joints\n        self.impedance_params = {\n            'ankle': {'M': 1.0, 'D': 10.0, 'K': 100.0},  # Mass, Damping, Stiffness\n            'hip': {'M': 2.0, 'D': 15.0, 'K': 80.0},\n            'knee': {'M': 1.5, 'D': 12.0, 'K': 90.0}\n        }\n\n    def compute_compliance_control(self, desired_pose, current_pose, external_force, joint_type='ankle'):\n        \"\"\"\n        Compute compliance control for balance\n        \"\"\"\n        params = self.impedance_params[joint_type]\n\n        # Calculate pose error\n        pose_error = desired_pose - current_pose\n\n        # Calculate desired acceleration based on impedance model\n        # M*\u1e8d + D*\u1e8b + K*x = F_external\n        desired_acc = (external_force - params['D'] * pose_error[3:] - params['K'] * pose_error[:3]) / params['M']\n\n        return desired_acc\n\n    def adaptive_compliance(self, current_state, disturbance_level):\n        \"\"\"\n        Adjust compliance based on disturbance level\n        \"\"\"\n        # Increase compliance (decrease stiffness) for larger disturbances\n        # to allow more flexible response\n        base_params = self.impedance_params.copy()\n\n        if disturbance_level > 0.5:  # Large disturbance\n            # Decrease stiffness, increase damping for more compliance\n            for joint_type in base_params:\n                base_params[joint_type]['K'] *= 0.5  # Reduce stiffness\n                base_params[joint_type]['D'] *= 1.5  # Increase damping\n        elif disturbance_level < 0.1:  # Small disturbance\n            # Increase stiffness for precise control\n            for joint_type in base_params:\n                base_params[joint_type]['K'] *= 1.5  # Increase stiffness\n\n        return base_params\n"})}),"\n",(0,r.jsx)(n.h2,{id:"balance-recovery-and-disturbance-handling",children:"Balance Recovery and Disturbance Handling"}),"\n",(0,r.jsx)(n.h3,{id:"disturbance-observer",children:"Disturbance Observer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class DisturbanceObserver:\n    def __init__(self, dt=0.01):\n        self.dt = dt\n        self.filter_coeff = 0.1  # Low-pass filter coefficient\n        self.estimated_disturbance = np.zeros(6)  # 3D force + 3D torque\n        self.disturbance_history = []\n\n    def estimate_disturbance(self, measured_force_torque, expected_force_torque):\n        \"\"\"\n        Estimate external disturbances using the difference between\n        measured and expected forces/torques\n        \"\"\"\n        # Calculate disturbance\n        disturbance = measured_force_torque - expected_force_torque\n\n        # Low-pass filter to reduce noise\n        self.estimated_disturbance = (\n            self.filter_coeff * disturbance +\n            (1 - self.filter_coeff) * self.estimated_disturbance\n        )\n\n        # Store for history\n        self.disturbance_history.append(self.estimated_disturbance.copy())\n        if len(self.disturbance_history) > 100:  # Keep last 100 samples\n            self.disturbance_history.pop(0)\n\n        return self.estimated_disturbance\n\n    def classify_disturbance(self, disturbance):\n        \"\"\"\n        Classify the type and magnitude of disturbance\n        \"\"\"\n        magnitude = np.linalg.norm(disturbance)\n\n        if magnitude < 5:  # Small disturbance\n            return {'type': 'small', 'magnitude': magnitude, 'direction': disturbance/magnitude if magnitude > 0 else np.zeros(6)}\n        elif magnitude < 20:  # Medium disturbance\n            return {'type': 'medium', 'magnitude': magnitude, 'direction': disturbance/magnitude if magnitude > 0 else np.zeros(6)}\n        else:  # Large disturbance\n            return {'type': 'large', 'magnitude': magnitude, 'direction': disturbance/magnitude if magnitude > 0 else np.zeros(6)}\n\n    def predict_disturbance_effect(self, disturbance, robot_state):\n        \"\"\"\n        Predict the effect of disturbance on robot balance\n        \"\"\"\n        # Use simplified model to predict CoM displacement\n        # This would involve more complex dynamics in practice\n        com_inertia = 70  # 70kg effective mass\n        predicted_com_acc = disturbance[:3] / com_inertia  # Only linear forces affect CoM directly\n\n        # Calculate time to reach critical state\n        current_com_vel = robot_state['com_vel']\n        critical_velocity = 0.5  # m/s - velocity threshold for concern\n\n        if np.linalg.norm(predicted_com_acc) > 0:\n            time_to_critical = (critical_velocity - np.linalg.norm(current_com_vel)) / np.linalg.norm(predicted_com_acc)\n        else:\n            time_to_critical = float('inf')\n\n        return {\n            'predicted_acceleration': predicted_com_acc,\n            'time_to_critical': time_to_critical,\n            'risk_level': 'low' if time_to_critical > 1.0 else 'medium' if time_to_critical > 0.3 else 'high'\n        }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"balance-recovery-planning",children:"Balance Recovery Planning"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class BalanceRecoveryPlanner:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.capturability_map = self.precompute_capturability()\n\n    def precompute_capturability(self):\n        \"\"\"\n        Precompute capturability regions for different CoM states\n        \"\"\"\n        # This would involve offline computation of capturability\n        # for different CoM positions and velocities\n        return {\n            'max_recoverable_velocity': 0.8,  # m/s\n            'max_recoverable_distance': 0.5,  # m\n            'capture_time_constant': 0.3    # s\n        }\n\n    def plan_recovery_action(self, current_state, disturbance_info):\n        \"\"\"\n        Plan balance recovery action based on current state and disturbance\n        \"\"\"\n        com_pos = current_state['com_pos']\n        com_vel = current_state['com_vel']\n\n        # Calculate capture point\n        omega = np.sqrt(9.81 / 0.8)  # sqrt(g/h) assuming 80cm CoM height\n        capture_point = com_pos[:2] + com_vel[:2] / omega\n\n        # Determine if recovery is possible\n        if self.is_recoverable(capture_point, current_state):\n            return self.plan_stable_recovery(current_state, capture_point)\n        else:\n            return self.plan_robust_recovery(current_state, capture_point)\n\n    def is_recoverable(self, capture_point, current_state):\n        \"\"\"\n        Check if balance recovery is possible from current state\n        \"\"\"\n        # Check if capture point is within reachable area\n        current_pos = current_state['base_pos'][:2]\n        distance_to_capture = np.linalg.norm(capture_point - current_pos)\n\n        # Check velocity is not too high\n        com_velocity_norm = np.linalg.norm(current_state['com_vel'])\n\n        # Recovery is possible if capture point is within reasonable distance\n        # and velocity is below threshold\n        return (distance_to_capture < self.capturability_map['max_recoverable_distance'] and\n                com_velocity_norm < self.capturability_map['max_recoverable_velocity'])\n\n    def plan_stable_recovery(self, current_state, capture_point):\n        \"\"\"\n        Plan stable recovery when capture point is reachable\n        \"\"\"\n        # Plan step to capture point\n        step_target = self.adjust_step_for_capture_point(current_state, capture_point)\n\n        # Generate smooth transition\n        recovery_plan = {\n            'type': 'stable_recovery',\n            'step_target': step_target,\n            'step_timing': 'next_opportunity',\n            'balance_strategy': 'step_to_capture',\n            'duration': 0.6  # 600ms for recovery step\n        }\n\n        return recovery_plan\n\n    def plan_robust_recovery(self, current_state, capture_point):\n        \"\"\"\n        Plan robust recovery for challenging situations\n        \"\"\"\n        # If capture point is not reachable, plan alternative strategy\n        current_pos = current_state['base_pos'][:2]\n\n        # Find nearest safe location within reach\n        direction_to_capture = capture_point - current_pos\n        distance_to_capture = np.linalg.norm(direction_to_capture)\n\n        if distance_to_capture > 0:\n            direction = direction_to_capture / distance_to_capture\n            max_reachable_distance = 0.4  # Maximum step length\n            safe_target = current_pos + min(distance_to_capture, max_reachable_distance) * direction\n        else:\n            safe_target = current_pos\n\n        recovery_plan = {\n            'type': 'robust_recovery',\n            'step_target': safe_target,\n            'step_timing': 'immediate',\n            'balance_strategy': 'max_effort_stabilization',\n            'additional_actions': ['arm_swing', 'hip_moment'],\n            'duration': 0.8  # Allow more time for challenging recovery\n        }\n\n        return recovery_plan\n\n    def adjust_step_for_capture_point(self, current_state, capture_point):\n        \"\"\"\n        Adjust step target to account for capture point and stability\n        \"\"\"\n        current_pos = current_state['base_pos'][:2]\n\n        # Calculate desired step direction\n        desired_direction = capture_point - current_pos\n        desired_distance = np.linalg.norm(desired_direction)\n\n        if desired_distance > 0:\n            desired_direction = desired_direction / desired_distance\n        else:\n            desired_direction = np.array([1, 0])  # Default direction\n\n        # Limit step distance to maximum comfortable step\n        max_step_length = 0.35  # 35cm maximum step\n        actual_distance = min(desired_distance, max_step_length)\n\n        # Add small safety margin\n        target_pos = current_pos + actual_distance * desired_direction\n\n        # Ensure target is on solid ground (simplified)\n        target_pos[2] = 0  # Ground level\n\n        return target_pos\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-example-integrated-balance-controller",children:"Implementation Example: Integrated Balance Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class IntegratedBalanceController:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.state_estimator = StateEstimator()\n        self.hierarchical_controller = HierarchicalBalanceController(robot_model)\n        self.disturbance_observer = DisturbanceObserver()\n        self.recovery_planner = BalanceRecoveryPlanner(robot_model)\n        self.mpc_controller = MPCBalanceController()\n\n        # Balance performance metrics\n        self.balance_metrics = {\n            'zmp_error_integral': 0,\n            'com_deviation_integral': 0,\n            'control_effort': 0,\n            'recovery_count': 0\n        }\n\n    def balance_control_step(self, sensor_data, dt=0.01):\n        \"\"\"\n        Main balance control step\n        \"\"\"\n        # 1. Update state estimate\n        current_state = self.update_state_estimate(sensor_data)\n\n        # 2. Estimate disturbances\n        disturbance_info = self.estimate_disturbances(current_state, sensor_data)\n\n        # 3. Select balance strategy\n        strategy = self.hierarchical_controller.select_balance_strategy(current_state)\n\n        # 4. Execute balance strategy\n        control_output = self.hierarchical_controller.execute_balance_strategy(\n            strategy, current_state\n        )\n\n        # 5. Apply MPC if needed for enhanced performance\n        if self.should_use_mpc(disturbance_info):\n            mpc_correction = self.mpc_controller.solve_balance_mpc(\n                current_state, self.generate_mpc_reference(current_state)\n            )\n            control_output['joint_torques'] += self.mpc_to_joint_torques(mpc_correction)\n\n        # 6. Update performance metrics\n        self.update_balance_metrics(current_state, control_output)\n\n        return control_output\n\n    def update_state_estimate(self, sensor_data):\n        \"\"\"\n        Update state estimate from sensor data\n        \"\"\"\n        # This would integrate sensor data using the state estimator\n        # For now, return a simplified state\n        return {\n            'com_pos': sensor_data.get('com_pos', np.array([0, 0, 0.8])),\n            'com_vel': sensor_data.get('com_vel', np.array([0, 0, 0])),\n            'com_acc': sensor_data.get('com_acc', np.array([0, 0, 0])),\n            'zmp_pos': sensor_data.get('zmp_pos', np.array([0, 0, 0])),\n            'base_pos': sensor_data.get('base_pos', np.array([0, 0, 0, 1, 0, 0, 0])),  # [pos, quat]\n            'base_vel': sensor_data.get('base_vel', np.array([0, 0, 0, 0, 0, 0])),  # [lin_vel, ang_vel]\n            'joint_positions': sensor_data.get('joint_positions', np.zeros(28)),\n            'joint_velocities': sensor_data.get('joint_velocities', np.zeros(28)),\n            'left_foot_pos': sensor_data.get('left_foot_pos', np.array([0, 0.1, 0])),\n            'right_foot_pos': sensor_data.get('right_foot_pos', np.array([0, -0.1, 0])),\n            'support_polygon': self.calculate_support_polygon(sensor_data)\n        }\n\n    def estimate_disturbances(self, current_state, sensor_data):\n        \"\"\"\n        Estimate external disturbances\n        \"\"\"\n        # Calculate expected vs measured forces\n        expected_forces = self.calculate_expected_forces(current_state)\n        measured_forces = sensor_data.get('force_torque', np.zeros(6))\n\n        disturbance = self.disturbance_observer.estimate_disturbance(\n            measured_forces, expected_forces\n        )\n\n        return self.disturbance_observer.classify_disturbance(disturbance)\n\n    def calculate_expected_forces(self, current_state):\n        \"\"\"\n        Calculate expected forces based on robot dynamics\n        \"\"\"\n        # Simplified calculation\n        total_weight = 70 * 9.81  # 70kg robot\n        return np.array([0, 0, -total_weight, 0, 0, 0])  # Gravity + no external forces\n\n    def calculate_support_polygon(self, sensor_data):\n        \"\"\"\n        Calculate support polygon from foot positions\n        \"\"\"\n        left_foot = sensor_data.get('left_foot_pos', np.array([0, 0.1, 0]))\n        right_foot = sensor_data.get('right_foot_pos', np.array([0, -0.1, 0]))\n\n        return {\n            'min_x': min(left_foot[0], right_foot[0]) - 0.02,  # Add small margin\n            'max_x': max(left_foot[0], right_foot[0]) + 0.02,\n            'min_y': min(left_foot[1], right_foot[1]) - 0.02,\n            'max_y': max(left_foot[1], right_foot[1]) + 0.02\n        }\n\n    def should_use_mpc(self, disturbance_info):\n        \"\"\"\n        Determine if MPC should be used based on disturbance level\n        \"\"\"\n        return disturbance_info['magnitude'] > 10  # Use MPC for significant disturbances\n\n    def generate_mpc_reference(self, current_state):\n        \"\"\"\n        Generate reference trajectory for MPC\n        \"\"\"\n        # Generate a short reference trajectory for MPC\n        reference_trajectory = []\n        for i in range(10):  # 10 steps\n            t = i * 0.01\n            # Simple reference: return to nominal CoM position\n            ref_com = current_state['com_pos'].copy()\n            ref_com[0] *= np.exp(-t)  # Exponentially decay to zero\n            ref_com[1] *= np.exp(-t)\n            reference_trajectory.append(ref_com)\n\n        return reference_trajectory\n\n    def mpc_to_joint_torques(self, mpc_control):\n        \"\"\"\n        Convert MPC control to joint torques\n        \"\"\"\n        # This would use inverse dynamics or other methods\n        n_joints = self.model.n_joints\n        return np.zeros(n_joints) * 0.1  # Small correction torques\n\n    def update_balance_metrics(self, current_state, control_output):\n        \"\"\"\n        Update balance performance metrics\n        \"\"\"\n        # Calculate ZMP error\n        zmp_error = np.linalg.norm(current_state['zmp_pos'][:2])\n        self.balance_metrics['zmp_error_integral'] += zmp_error * 0.01\n\n        # Calculate CoM deviation from nominal\n        com_deviation = np.linalg.norm(current_state['com_pos'][:2])\n        self.balance_metrics['com_deviation_integral'] += com_deviation * 0.01\n\n        # Calculate control effort\n        control_effort = np.sum(np.abs(control_output['joint_torques']))\n        self.balance_metrics['control_effort'] += control_effort * 0.01\n\n    def get_balance_performance(self):\n        \"\"\"\n        Get current balance performance metrics\n        \"\"\"\n        return self.balance_metrics.copy()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"simulation-and-testing",children:"Simulation and Testing"}),"\n",(0,r.jsx)(n.h3,{id:"balance-control-testing-framework",children:"Balance Control Testing Framework"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class BalanceControlTester:\n    def __init__(self, robot_model, controller):\n        self.model = robot_model\n        self.controller = controller\n        self.simulator = self.initialize_simulator()\n\n    def initialize_simulator(self):\n        \"\"\"\n        Initialize physics simulator for balance testing\n        \"\"\"\n        return {\n            'gravity': 9.81,\n            'timestep': 0.001,  # Fine-grained simulation\n            'total_time': 10.0,  # 10 seconds simulation\n            'disturbance_times': [2.0, 4.0, 6.0, 8.0],  # Times to apply disturbances\n            'disturbance_magnitudes': [50, 100, 75, 125]  # Force magnitudes (N)\n        }\n\n    def test_static_balance(self, initial_state):\n        \"\"\"\n        Test static balance maintenance\n        \"\"\"\n        print(\"Testing static balance...\")\n\n        # Apply no external disturbances\n        simulation_data = self.run_simulation(initial_state, disturbances=[])\n\n        # Analyze results\n        stability_score = self.analyze_static_balance(simulation_data)\n\n        return {\n            'stability_score': stability_score,\n            'max_com_deviation': np.max(np.abs(simulation_data['com_trajectory'][:, :2])),\n            'average_zmp_error': np.mean(simulation_data['zmp_errors']),\n            'success': stability_score > 0.8\n        }\n\n    def test_dynamic_balance(self, walking_pattern):\n        \"\"\"\n        Test balance during dynamic motion (walking)\n        \"\"\"\n        print(\"Testing dynamic balance during walking...\")\n\n        # Start with walking pattern\n        initial_state = self.generate_walking_start_state()\n\n        # Apply periodic disturbances during walking\n        disturbances = self.generate_walking_disturbances()\n\n        simulation_data = self.run_simulation(initial_state, disturbances)\n\n        # Analyze results\n        walking_stability = self.analyze_walking_balance(simulation_data)\n\n        return {\n            'walking_stability': walking_stability,\n            'step_success_rate': self.calculate_step_success(simulation_data),\n            'average_balance_effort': self.calculate_balance_effort(simulation_data),\n            'success': walking_stability > 0.7\n        }\n\n    def test_disturbance_recovery(self, disturbance_magnitude=100):\n        \"\"\"\n        Test recovery from external disturbances\n        \"\"\"\n        print(f\"Testing disturbance recovery (magnitude: {disturbance_magnitude}N)...\")\n\n        initial_state = self.generate_balanced_state()\n\n        # Apply single large disturbance\n        disturbances = [{'time': 1.0, 'force': [disturbance_magnitude, 0, 0], 'duration': 0.1}]\n\n        simulation_data = self.run_simulation(initial_state, disturbances)\n\n        # Analyze recovery performance\n        recovery_performance = self.analyze_disturbance_recovery(simulation_data)\n\n        return {\n            'recovery_time': recovery_performance['recovery_time'],\n            'recovery_accuracy': recovery_performance['accuracy'],\n            'recovery_energy': recovery_performance['energy'],\n            'success': recovery_performance['success']\n        }\n\n    def run_simulation(self, initial_state, disturbances):\n        \"\"\"\n        Run full balance control simulation\n        \"\"\"\n        sim_data = {\n            'time': [],\n            'states': [],\n            'controls': [],\n            'com_trajectory': [],\n            'zmp_trajectory': [],\n            'zmp_errors': [],\n            'joint_torques': [],\n            'disturbance_applied': []\n        }\n\n        state = initial_state.copy()\n        sim_time = 0.0\n        dt = 0.01  # Control timestep\n\n        while sim_time < self.simulator['total_time']:\n            # Apply disturbances if scheduled\n            current_disturbance = self.get_current_disturbance(disturbances, sim_time)\n            if current_disturbance is not None:\n                state = self.apply_disturbance(state, current_disturbance)\n                sim_data['disturbance_applied'].append((sim_time, current_disturbance))\n\n            # Get sensor data (with noise simulation)\n            sensor_data = self.generate_sensor_data(state, sim_time)\n\n            # Run balance controller\n            control_output = self.controller.balance_control_step(sensor_data, dt)\n\n            # Apply control to robot dynamics\n            state = self.update_robot_dynamics(state, control_output['joint_torques'], dt)\n\n            # Log data\n            sim_data['time'].append(sim_time)\n            sim_data['states'].append(state.copy())\n            sim_data['controls'].append(control_output.copy())\n            sim_data['com_trajectory'].append(state['com_pos'].copy())\n            sim_data['zmp_trajectory'].append(state['zmp_pos'].copy())\n\n            # Calculate ZMP error\n            support_polygon = state['support_polygon']\n            zmp_pos = state['zmp_pos'][:2]\n            zmp_error = self.calculate_zmp_error(zmp_pos, support_polygon)\n            sim_data['zmp_errors'].append(zmp_error)\n\n            sim_data['joint_torques'].append(control_output['joint_torques'].copy())\n\n            sim_time += dt\n\n        return sim_data\n\n    def get_current_disturbance(self, disturbances, current_time):\n        \"\"\"\n        Get disturbance to apply at current time\n        \"\"\"\n        for dist in disturbances:\n            if dist['time'] <= current_time < dist['time'] + dist.get('duration', 0.1):\n                return dist\n        return None\n\n    def apply_disturbance(self, state, disturbance):\n        \"\"\"\n        Apply external disturbance to robot state\n        \"\"\"\n        # Apply force to CoM\n        force = np.array(disturbance['force'])\n        mass = 70  # 70kg robot\n        acceleration = force / mass\n\n        # Update CoM velocity\n        state['com_vel'][:3] += acceleration * 0.01  # Apply for 1 control cycle\n\n        return state\n\n    def generate_sensor_data(self, state, time):\n        \"\"\"\n        Generate sensor data with realistic noise\n        \"\"\"\n        # Add realistic sensor noise\n        noise_level = 0.001\n        com_pos_noisy = state['com_pos'] + np.random.normal(0, noise_level, 3)\n        com_vel_noisy = state['com_vel'] + np.random.normal(0, noise_level*10, 3)\n\n        return {\n            'com_pos': com_pos_noisy,\n            'com_vel': com_vel_noisy,\n            'zmp_pos': state['zmp_pos'],\n            'base_pos': state['base_pos'],\n            'base_vel': state['base_vel'],\n            'joint_positions': state['joint_positions'] + np.random.normal(0, 0.0005, len(state['joint_positions'])),\n            'joint_velocities': state['joint_velocities'],\n            'left_foot_pos': state['left_foot_pos'],\n            'right_foot_pos': state['right_foot_pos'],\n            'force_torque': np.random.normal(0, 0.1, 6)  # Simulated force/torque noise\n        }\n\n    def update_robot_dynamics(self, state, joint_torques, dt):\n        \"\"\"\n        Update robot dynamics with applied torques\n        \"\"\"\n        # Simplified dynamics update\n        # In practice, this would use full rigid body dynamics\n        new_state = state.copy()\n\n        # Apply joint torques and update joint velocities/positions\n        joint_acc = joint_torques / 1.0  # Simplified inertia\n        new_state['joint_velocities'] += joint_acc * dt\n        new_state['joint_positions'] += new_state['joint_velocities'] * dt\n\n        # Update CoM based on new configuration\n        new_state['com_pos'] = self.model.calculate_com_position(new_state['joint_positions'])\n        new_state['com_vel'] = self.model.calculate_com_velocity(\n            new_state['joint_positions'], new_state['joint_velocities']\n        )\n\n        return new_state\n\n    def calculate_zmp_error(self, zmp_pos, support_polygon):\n        \"\"\"\n        Calculate ZMP error relative to support polygon\n        \"\"\"\n        # Distance to closest boundary of support polygon\n        errors = [\n            abs(zmp_pos[0] - support_polygon['min_x']),\n            abs(zmp_pos[0] - support_polygon['max_x']),\n            abs(zmp_pos[1] - support_polygon['min_y']),\n            abs(zmp_pos[1] - support_polygon['max_y'])\n        ]\n\n        return min(errors)  # Distance to nearest boundary\n\n    def analyze_static_balance(self, sim_data):\n        \"\"\"\n        Analyze static balance performance\n        \"\"\"\n        zmp_errors = np.array(sim_data['zmp_errors'])\n        com_deviations = np.array([np.linalg.norm(state['com_pos'][:2]) for state in sim_data['states']])\n\n        # Calculate stability metrics\n        avg_zmp_error = np.mean(zmp_errors)\n        max_zmp_error = np.max(zmp_errors)\n        avg_com_deviation = np.mean(com_deviations)\n\n        # Stability score (lower is better)\n        stability_score = 1.0 / (1.0 + avg_zmp_error + avg_com_deviation)\n\n        return stability_score\n\n    def analyze_walking_balance(self, sim_data):\n        \"\"\"\n        Analyze balance during walking\n        \"\"\"\n        # Calculate metrics specific to walking balance\n        pass\n\n    def calculate_step_success(self, sim_data):\n        \"\"\"\n        Calculate step success rate\n        \"\"\"\n        pass\n\n    def calculate_balance_effort(self, sim_data):\n        \"\"\"\n        Calculate average balance control effort\n        \"\"\"\n        joint_torques = np.array(sim_data['joint_torques'])\n        avg_effort = np.mean(np.abs(joint_torques))\n        return avg_effort\n\n    def analyze_disturbance_recovery(self, sim_data):\n        \"\"\"\n        Analyze disturbance recovery performance\n        \"\"\"\n        # Find when robot recovered to stable state\n        zmp_errors = np.array(sim_data['zmp_errors'])\n        com_trajectory = np.array(sim_data['com_trajectory'])\n\n        # Find recovery time (when ZMP error returns to acceptable range)\n        recovery_threshold = 0.05  # 5cm from support polygon edge\n        recovery_time_idx = None\n\n        for i, error in enumerate(zmp_errors):\n            if error < recovery_threshold:\n                recovery_time_idx = i\n                break\n\n        if recovery_time_idx is not None:\n            recovery_time = sim_data['time'][recovery_time_idx]\n            recovery_accuracy = zmp_errors[recovery_time_idx]\n        else:\n            recovery_time = self.simulator['total_time']  # Did not recover\n            recovery_accuracy = np.max(zmp_errors)\n\n        # Calculate energy used for recovery\n        joint_torques = np.array(sim_data['joint_torques'])\n        recovery_energy = np.sum(np.abs(joint_torques[:recovery_time_idx])) if recovery_time_idx else float('inf')\n\n        return {\n            'recovery_time': recovery_time,\n            'accuracy': recovery_accuracy,\n            'energy': recovery_energy,\n            'success': recovery_time < self.simulator['total_time'] * 0.8  # Recovered in time\n        }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Balance and postural control are critical capabilities for humanoid robots, enabling them to maintain stability during both static and dynamic activities. The key components covered in this section include:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Estimation"}),": Accurate estimation of robot state using sensor fusion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Balance Control Strategies"}),": Ankle, hip, and stepping strategies for different disturbance levels"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mathematical Models"}),": LIPM, Cart-Table, and other models for balance control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advanced Techniques"}),": MPC, compliance control, and disturbance handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recovery Planning"}),": Proactive planning for balance recovery"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The balance control system must be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rapidly detect balance disturbances"}),"\n",(0,r.jsx)(n.li,{children:"Select appropriate control strategies based on disturbance magnitude"}),"\n",(0,r.jsx)(n.li,{children:"Coordinate multiple joints to maintain stability"}),"\n",(0,r.jsx)(n.li,{children:"Plan and execute recovery actions when necessary"}),"\n",(0,r.jsx)(n.li,{children:"Adapt to changing conditions and environments"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Effective balance control requires careful integration of these components, along with extensive testing and tuning to achieve stable and robust performance. The next section will cover manipulation and grasping techniques for humanoid robots."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var o=t(6540);const r={},a=o.createContext(r);function s(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);