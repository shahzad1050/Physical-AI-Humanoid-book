"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[3894],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const o={},s=t.createContext(o);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},9931:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module4/bipedal-locomotion","title":"Bipedal Locomotion","description":"Introduction to Bipedal Locomotion","source":"@site/docs/module4/bipedal-locomotion.md","sourceDirName":"module4","slug":"/module4/bipedal-locomotion","permalink":"/Physical-AI-Humanoid-book/docs/module4/bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/user/physical-ai-humanoid-robotics/tree/main/docs/module4/bipedal-locomotion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Balance and Postural Control","permalink":"/Physical-AI-Humanoid-book/docs/module4/balance-control"},"next":{"title":"Module 4 Conclusion: Humanoid Robot Development","permalink":"/Physical-AI-Humanoid-book/docs/module4/conclusion"}}');var o=r(4848),s=r(8453);const a={},i="Bipedal Locomotion",l={},c=[{value:"Introduction to Bipedal Locomotion",id:"introduction-to-bipedal-locomotion",level:2},{value:"Fundamentals of Human Walking",id:"fundamentals-of-human-walking",level:2},{value:"Gait Cycle",id:"gait-cycle",level:3},{value:"Key Biomechanical Principles",id:"key-biomechanical-principles",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Center of Mass Trajectory",id:"center-of-mass-trajectory",level:3},{value:"Footstep Planning",id:"footstep-planning",level:3},{value:"Zero Moment Point (ZMP) Based Walking",id:"zero-moment-point-zmp-based-walking",level:2},{value:"ZMP Fundamentals",id:"zmp-fundamentals",level:3},{value:"Preview Control for ZMP Tracking",id:"preview-control-for-zmp-tracking",level:3},{value:"Walking Pattern Generators",id:"walking-pattern-generators",level:2},{value:"Foot Trajectory Generation",id:"foot-trajectory-generation",level:3},{value:"Walking Controllers",id:"walking-controllers",level:2},{value:"Joint Space Walking Controller",id:"joint-space-walking-controller",level:3},{value:"Advanced Walking Techniques",id:"advanced-walking-techniques",level:2},{value:"Walking on Uneven Terrain",id:"walking-on-uneven-terrain",level:3},{value:"Walking Stability and Recovery",id:"walking-stability-and-recovery",level:2},{value:"Disturbance Recovery",id:"disturbance-recovery",level:3},{value:"Walking Simulation and Testing",id:"walking-simulation-and-testing",level:2},{value:"Walking Simulation Environment",id:"walking-simulation-environment",level:3},{value:"Summary",id:"summary",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"bipedal-locomotion",children:"Bipedal Locomotion"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-bipedal-locomotion",children:"Introduction to Bipedal Locomotion"}),"\n",(0,o.jsx)(n.p,{children:"Bipedal locomotion is one of the most challenging and fascinating aspects of humanoid robotics. Unlike wheeled or tracked robots, bipedal robots must dynamically balance on two legs while walking, requiring sophisticated control algorithms and careful mechanical design. The ability to walk like humans enables humanoid robots to navigate human environments effectively and interact with human-designed infrastructure."}),"\n",(0,o.jsx)(n.h2,{id:"fundamentals-of-human-walking",children:"Fundamentals of Human Walking"}),"\n",(0,o.jsx)(n.h3,{id:"gait-cycle",children:"Gait Cycle"}),"\n",(0,o.jsx)(n.p,{children:"Human walking consists of a repeating gait cycle with two main phases:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Stance Phase (60% of cycle)"}),": The foot is in contact with the ground"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Initial contact"}),"\n",(0,o.jsx)(n.li,{children:"Loading response"}),"\n",(0,o.jsx)(n.li,{children:"Mid stance"}),"\n",(0,o.jsx)(n.li,{children:"Terminal stance"}),"\n",(0,o.jsx)(n.li,{children:"Pre-swing"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Swing Phase (40% of cycle)"}),": The foot is off the ground, moving forward"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Initial swing"}),"\n",(0,o.jsx)(n.li,{children:"Mid swing"}),"\n",(0,o.jsx)(n.li,{children:"Terminal swing"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-biomechanical-principles",children:"Key Biomechanical Principles"}),"\n",(0,o.jsx)(n.p,{children:"Human walking is efficient due to several biomechanical principles:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Passive Dynamics"}),": Energy-efficient motion using pendulum-like mechanics"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ground Reaction Forces"}),": Proper force application for forward progression"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Center of Mass (CoM) Movement"}),": Controlled CoM trajectory for stability"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ankle Strategy"}),": Using ankle torques for balance and propulsion"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,o.jsx)(n.h3,{id:"center-of-mass-trajectory",children:"Center of Mass Trajectory"}),"\n",(0,o.jsx)(n.p,{children:"The Center of Mass (CoM) trajectory is crucial for stable walking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom scipy import signal\r\n\r\nclass CoMTrajectoryGenerator:\r\n    def __init__(self, walking_height=0.8, step_length=0.3, step_time=0.8):\r\n        self.h = walking_height  # CoM height\r\n        self.step_length = step_length\r\n        self.step_time = step_time\r\n        self.g = 9.81  # Gravity\r\n\r\n    def generate_3d_com_trajectory(self, steps, start_pos=np.array([0, 0, 0.8])):\r\n        """\r\n        Generate 3D CoM trajectory for walking\r\n        """\r\n        dt = 0.01  # 100Hz control rate\r\n        total_time = steps * self.step_time\r\n        timesteps = int(total_time / dt)\r\n\r\n        # Initialize trajectory arrays\r\n        com_trajectory = np.zeros((timesteps, 3))\r\n        com_velocity = np.zeros((timesteps, 3))\r\n        com_acceleration = np.zeros((timesteps, 3))\r\n\r\n        # Generate trajectories for each axis\r\n        t = np.linspace(0, total_time, timesteps)\r\n\r\n        # X-axis: forward progression with periodic motion\r\n        x_pos = np.zeros(timesteps)\r\n        for i in range(steps):\r\n            step_start = i * self.step_time\r\n            step_end = (i + 1) * self.step_time\r\n            mask = (t >= step_start) & (t < step_end)\r\n            if np.any(mask):\r\n                # Smooth progression using 5th order polynomial\r\n                phase = (t[mask] - step_start) / self.step_time\r\n                x_progress = self.step_length * self.smooth_step(phase)\r\n                x_pos[mask] = i * self.step_length + x_progress\r\n\r\n        # Y-axis: lateral sway for stability (double support phase)\r\n        y_pos = self.generate_lateral_sway(t, steps)\r\n\r\n        # Z-axis: vertical oscillation (pelvic motion)\r\n        z_pos = start_pos[2] + 0.02 * np.sin(2 * np.pi * t / self.step_time)  # Small vertical oscillation\r\n\r\n        com_trajectory[:, 0] = x_pos\r\n        com_trajectory[:, 1] = y_pos\r\n        com_trajectory[:, 2] = z_pos\r\n\r\n        # Calculate velocities and accelerations\r\n        for i in range(3):\r\n            com_velocity[:, i] = np.gradient(com_trajectory[:, i], dt)\r\n            com_acceleration[:, i] = np.gradient(com_velocity[:, i], dt)\r\n\r\n        return com_trajectory, com_velocity, com_acceleration\r\n\r\n    def smooth_step(self, t):\r\n        """\r\n        5th order polynomial for smooth motion profile\r\n        """\r\n        return 6*t**5 - 15*t**4 + 10*t**3\r\n\r\n    def generate_lateral_sway(self, t, steps):\r\n        """\r\n        Generate lateral sway for stability\r\n        """\r\n        y_pos = np.zeros_like(t)\r\n        step_frequency = 1.0 / self.step_time\r\n\r\n        for i in range(steps):\r\n            step_start = i * self.step_time\r\n            step_end = (i + 1) * self.step_time\r\n            mask = (t >= step_start) & (t < step_end)\r\n\r\n            if np.any(mask):\r\n                phase = (t[mask] - step_start) / self.step_time\r\n                # Lateral sway: shift CoM toward stance leg\r\n                if i % 2 == 0:  # Right leg stance (left foot moves)\r\n                    y_offset = -0.05 * np.sin(np.pi * phase)  # Move toward stance leg\r\n                else:  # Left leg stance (right foot moves)\r\n                    y_offset = 0.05 * np.sin(np.pi * phase)   # Move toward stance leg\r\n\r\n                y_pos[mask] = y_offset\r\n\r\n        return y_pos\r\n\r\n    def plot_trajectory(self, com_trajectory):\r\n        """\r\n        Plot the CoM trajectory\r\n        """\r\n        t = np.linspace(0, len(com_trajectory) * 0.01, len(com_trajectory))\r\n\r\n        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 8))\r\n\r\n        ax1.plot(t, com_trajectory[:, 0])\r\n        ax1.set_ylabel(\'X Position (m)\')\r\n        ax1.set_title(\'CoM Trajectory - X Axis\')\r\n\r\n        ax2.plot(t, com_trajectory[:, 1])\r\n        ax2.set_ylabel(\'Y Position (m)\')\r\n        ax2.set_title(\'CoM Trajectory - Y Axis\')\r\n\r\n        ax3.plot(t, com_trajectory[:, 2])\r\n        ax3.set_ylabel(\'Z Position (m)\')\r\n        ax3.set_xlabel(\'Time (s)\')\r\n        ax3.set_title(\'CoM Trajectory - Z Axis\')\r\n\r\n        plt.tight_layout()\r\n        plt.show()\n'})}),"\n",(0,o.jsx)(n.h3,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,o.jsx)(n.p,{children:"Footstep planning determines where and when the feet should be placed:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class FootstepPlanner:\r\n    def __init__(self, step_width=0.2, step_length=0.3, max_step_width=0.4):\r\n        self.step_width = step_width\r\n        self.step_length = step_length\r\n        self.max_step_width = max_step_width\r\n\r\n    def plan_forward_walk(self, num_steps, start_pose=np.array([0, 0, 0])):\r\n        """\r\n        Plan footsteps for forward walking\r\n        """\r\n        footsteps = []\r\n\r\n        current_pose = start_pose.copy()\r\n\r\n        for i in range(num_steps):\r\n            # Determine which foot to step with\r\n            is_left_foot = (i % 2) == 0  # Start with left foot\r\n\r\n            # Calculate step position\r\n            step_x = current_pose[0] + self.step_length\r\n            step_y = current_pose[1] + (self.step_width if is_left_foot else -self.step_width)\r\n            step_theta = current_pose[2]  # Maintain heading\r\n\r\n            foot_pose = np.array([step_x, step_y, step_theta])\r\n            footsteps.append({\r\n                \'position\': foot_pose,\r\n                \'is_left\': is_left_foot,\r\n                \'step_number\': i\r\n            })\r\n\r\n            # Update current pose for next step\r\n            current_pose[0] = step_x\r\n\r\n        return footsteps\r\n\r\n    def plan_turning_walk(self, turn_angle, num_steps, start_pose=np.array([0, 0, 0])):\r\n        """\r\n        Plan footsteps for turning motion\r\n        """\r\n        footsteps = []\r\n        current_pose = start_pose.copy()\r\n\r\n        angle_per_step = turn_angle / num_steps\r\n\r\n        for i in range(num_steps):\r\n            is_left_foot = (i % 2) == 0\r\n\r\n            # Calculate turning arc\r\n            turn_radius = self.step_length / (2 * np.sin(angle_per_step / 2)) if angle_per_step != 0 else float(\'inf\')\r\n\r\n            if turn_radius != float(\'inf\'):\r\n                # Calculate new position after turning\r\n                step_x = current_pose[0] + self.step_length * np.cos(current_pose[2] + angle_per_step/2)\r\n                step_y = current_pose[1] + self.step_length * np.sin(current_pose[2] + angle_per_step/2)\r\n            else:\r\n                # Straight line if no turn\r\n                step_x = current_pose[0] + self.step_length * np.cos(current_pose[2])\r\n                step_y = current_pose[1] + self.step_length * np.sin(current_pose[2])\r\n\r\n            step_theta = current_pose[2] + angle_per_step\r\n\r\n            # Adjust foot placement for turning\r\n            if is_left_foot:\r\n                # Left foot placement during right turn (or vice versa)\r\n                step_y += self.step_width * np.cos(angle_per_step/2)\r\n            else:\r\n                step_y -= self.step_width * np.cos(angle_per_step/2)\r\n\r\n            foot_pose = np.array([step_x, step_y, step_theta])\r\n            footsteps.append({\r\n                \'position\': foot_pose,\r\n                \'is_left\': is_left_foot,\r\n                \'step_number\': i\r\n            })\r\n\r\n            current_pose = np.array([step_x, step_y, step_theta])\r\n\r\n        return footsteps\r\n\r\n    def plan_sideways_walk(self, num_steps, start_pose=np.array([0, 0, 0])):\r\n        """\r\n        Plan footsteps for sideways walking (lateral movement)\r\n        """\r\n        footsteps = []\r\n        current_pose = start_pose.copy()\r\n\r\n        for i in range(num_steps):\r\n            is_left_foot = (i % 2) == 0\r\n\r\n            # For sideways walking, step in Y direction\r\n            step_x = current_pose[0]\r\n            step_y = current_pose[1] + (self.step_width if is_left_foot else -self.step_width)\r\n            step_theta = current_pose[2]\r\n\r\n            # Alternate feet placement for stability\r\n            if i > 0:\r\n                # Adjust the other foot to maintain balance\r\n                if is_left_foot:\r\n                    step_y += 0.1  # Small offset for left foot\r\n                else:\r\n                    step_y -= 0.1  # Small offset for right foot\r\n\r\n            foot_pose = np.array([step_x, step_y, step_theta])\r\n            footsteps.append({\r\n                \'position\': foot_pose,\r\n                \'is_left\': is_left_foot,\r\n                \'step_number\': i\r\n            })\r\n\r\n            current_pose = foot_pose.copy()\r\n\r\n        return footsteps\r\n\r\n    def check_footstep_feasibility(self, footstep, obstacles=None):\r\n        """\r\n        Check if a footstep is feasible given obstacles\r\n        """\r\n        if obstacles is None:\r\n            obstacles = []\r\n\r\n        # Check for collisions with obstacles\r\n        for obs in obstacles:\r\n            if self.distance_to_obstacle(footstep[\'position\'][:2], obs) < 0.1:  # 10cm clearance\r\n                return False, "Footstep collides with obstacle"\r\n\r\n        # Check if footstep is within reachable workspace\r\n        if abs(footstep[\'position\'][1]) > self.max_step_width:\r\n            return False, "Footstep exceeds maximum lateral reach"\r\n\r\n        return True, "Footstep is feasible"\r\n\r\n    def distance_to_obstacle(self, point, obstacle):\r\n        """\r\n        Calculate distance from point to obstacle\r\n        """\r\n        # Simplified distance calculation (assuming circular obstacles)\r\n        center = obstacle[\'center\']\r\n        radius = obstacle.get(\'radius\', 0.1)\r\n        return np.linalg.norm(point - center[:2]) - radius\n'})}),"\n",(0,o.jsx)(n.h2,{id:"zero-moment-point-zmp-based-walking",children:"Zero Moment Point (ZMP) Based Walking"}),"\n",(0,o.jsx)(n.h3,{id:"zmp-fundamentals",children:"ZMP Fundamentals"}),"\n",(0,o.jsx)(n.p,{children:"The Zero Moment Point is a critical concept in bipedal walking control:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class ZMPController:\r\n    def __init__(self, com_height=0.8, gravity=9.81):\r\n        self.h = com_height\r\n        self.g = gravity\r\n        self.omega = np.sqrt(self.g / self.h)\r\n\r\n    def calculate_zmp_from_com(self, com_pos, com_vel, com_acc):\r\n        """\r\n        Calculate ZMP from CoM state\r\n        """\r\n        x_com, y_com = com_pos[0], com_pos[1]\r\n        x_com_dot, y_com_dot = com_vel[0], com_vel[1]\r\n        x_com_ddot, y_com_ddot = com_acc[0], com_acc[1]\r\n\r\n        # ZMP equations\r\n        zmp_x = x_com - (self.h / self.g) * x_com_ddot\r\n        zmp_y = y_com - (self.h / self.g) * y_com_ddot\r\n\r\n        return np.array([zmp_x, zmp_y, 0.0])\r\n\r\n    def calculate_com_from_zmp(self, zmp_trajectory, initial_com, initial_com_vel):\r\n        """\r\n        Calculate CoM trajectory from ZMP reference using inverted pendulum model\r\n        """\r\n        dt = 0.01  # Control timestep\r\n        n_points = len(zmp_trajectory)\r\n\r\n        com_pos = np.zeros((n_points, 3))\r\n        com_vel = np.zeros((n_points, 3))\r\n        com_acc = np.zeros((n_points, 3))\r\n\r\n        # Initialize with given conditions\r\n        com_pos[0] = initial_com\r\n        com_vel[0] = initial_com_vel\r\n\r\n        for i in range(1, n_points):\r\n            # Inverted pendulum dynamics: com_ddot = g/h * (com - zmp)\r\n            com_acc[i, 0] = (self.g / self.h) * (com_pos[i-1, 0] - zmp_trajectory[i-1, 0])\r\n            com_acc[i, 1] = (self.g / self.h) * (com_pos[i-1, 1] - zmp_trajectory[i-1, 1])\r\n            com_acc[i, 2] = 0  # Assume constant height\r\n\r\n            # Integrate to get velocity and position\r\n            com_vel[i] = com_vel[i-1] + com_acc[i] * dt\r\n            com_pos[i] = com_pos[i-1] + com_vel[i] * dt\r\n\r\n        return com_pos, com_vel, com_acc\r\n\r\n    def generate_zmp_trajectory(self, footsteps, step_time=0.8, dt=0.01):\r\n        """\r\n        Generate ZMP trajectory following footsteps\r\n        """\r\n        n_steps = len(footsteps)\r\n        step_samples = int(step_time / dt)\r\n        total_samples = n_steps * step_samples\r\n\r\n        zmp_trajectory = np.zeros((total_samples, 3))\r\n\r\n        for i, footstep in enumerate(footsteps):\r\n            start_idx = i * step_samples\r\n            end_idx = min((i + 1) * step_samples, total_samples)\r\n\r\n            # ZMP should be under the supporting foot\r\n            support_foot_pos = footstep[\'position\'][:2]\r\n\r\n            # Smooth transition from previous support foot to new support foot\r\n            if i > 0:\r\n                prev_footstep = footsteps[i-1]\r\n                prev_support_pos = prev_footstep[\'position\'][:2]\r\n\r\n                for j in range(start_idx, end_idx):\r\n                    if j < start_idx + step_samples // 4:  # Double support phase\r\n                        # Interpolate between old and new support foot\r\n                        alpha = (j - start_idx) / (step_samples // 4)\r\n                        zmp_trajectory[j, :2] = (1 - alpha) * prev_support_pos + alpha * support_foot_pos\r\n                    else:  # Single support phase\r\n                        zmp_trajectory[j, :2] = support_foot_pos\r\n            else:\r\n                # First step - start at initial support foot\r\n                zmp_trajectory[start_idx:end_idx, :2] = support_foot_pos\r\n\r\n            # Maintain ZMP at foot level (z=0)\r\n            zmp_trajectory[start_idx:end_idx, 2] = 0.0\r\n\r\n        return zmp_trajectory\r\n\r\n    def calculate_support_polygon(self, left_foot_pos, right_foot_pos):\r\n        """\r\n        Calculate support polygon from foot positions\r\n        """\r\n        # For two feet, support polygon is the convex hull of both feet\r\n        # Simplified as a rectangle encompassing both feet\r\n        min_x = min(left_foot_pos[0], right_foot_pos[0])\r\n        max_x = max(left_foot_pos[0], right_foot_pos[0])\r\n        min_y = min(left_foot_pos[1], right_foot_pos[1])\r\n        max_y = max(left_foot_pos[1], right_foot_pos[1])\r\n\r\n        # Add some margin for stability\r\n        margin = 0.02  # 2cm margin\r\n        return {\r\n            \'min_x\': min_x - margin,\r\n            \'max_x\': max_x + margin,\r\n            \'min_y\': min_y - margin,\r\n            \'max_y\': max_y + margin\r\n        }\r\n\r\n    def is_zmp_stable(self, zmp_pos, support_polygon):\r\n        """\r\n        Check if ZMP is within support polygon\r\n        """\r\n        return (support_polygon[\'min_x\'] <= zmp_pos[0] <= support_polygon[\'max_x\'] and\r\n                support_polygon[\'min_y\'] <= zmp_pos[1] <= support_polygon[\'max_y\'])\n'})}),"\n",(0,o.jsx)(n.h3,{id:"preview-control-for-zmp-tracking",children:"Preview Control for ZMP Tracking"}),"\n",(0,o.jsx)(n.p,{children:"Preview control improves ZMP tracking by considering future reference:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class PreviewController:\r\n    def __init__(self, com_height=0.8, preview_time=2.0, dt=0.01):\r\n        self.h = com_height\r\n        self.preview_time = preview_time\r\n        self.dt = dt\r\n        self.g = 9.81\r\n        self.omega = np.sqrt(self.g / self.h)\r\n\r\n        # Calculate preview control gains\r\n        self.K_x, self.K_v, self.K_preview = self.calculate_preview_gains()\r\n\r\n    def calculate_preview_gains(self):\r\n        """\r\n        Calculate preview control gains by solving Riccati equation\r\n        """\r\n        # System matrices for inverted pendulum\r\n        A = np.array([[0, 1], [self.omega**2, 0]])  # State matrix\r\n        B = np.array([0, -self.omega**2])          # Input matrix\r\n\r\n        # Discretize system\r\n        I = np.eye(2)\r\n        A_d = I + A * self.dt + (A @ A) * (self.dt**2) / 2  # Approximate discretization\r\n        B_d = B * self.dt + (A @ B) * (self.dt**2) / 2\r\n\r\n        # Design parameters\r\n        Q = np.array([[100, 0], [0, 10]])  # State cost\r\n        R = 1.0                           # Control cost\r\n\r\n        # Solve discrete-time Riccati equation (simplified approach)\r\n        # In practice, this would use more sophisticated methods\r\n        P = np.array([[10, 0], [0, 1]])  # Solution to Riccati equation\r\n\r\n        # Feedback gain\r\n        K = (B_d.T @ P @ A_d) / (R + B_d.T @ P @ B_d)\r\n\r\n        # Preview gains calculation (simplified)\r\n        preview_steps = int(self.preview_time / self.dt)\r\n        preview_gains = np.zeros(preview_steps)\r\n\r\n        # Calculate preview gains based on system dynamics\r\n        for i in range(preview_steps):\r\n            k = i * self.dt\r\n            preview_gains[i] = self.omega * np.exp(-self.omega * k) * self.dt\r\n\r\n        return K[0], K[1], preview_gains\r\n\r\n    def compute_control(self, current_com, current_com_vel, zmp_reference):\r\n        """\r\n        Compute control using preview of future ZMP reference\r\n        """\r\n        current_state = np.array([current_com[0], current_com_vel[0]])  # Simplified to x-axis\r\n        reference_zmp = zmp_reference[0]  # X component of ZMP reference\r\n\r\n        # Current error\r\n        zmp_current = current_com[0] - (self.h / self.g) * current_com_vel[0]  # Simplified ZMP calculation\r\n        error = reference_zmp - zmp_current\r\n\r\n        # Feedback control\r\n        feedback_control = self.K_x * (reference_zmp - current_com[0]) + \\\r\n                          self.K_v * (0 - current_com_vel[0])  # Assuming desired velocity is 0\r\n\r\n        # Preview control (simplified)\r\n        preview_control = 0\r\n        if len(zmp_reference) > 1:\r\n            for i, future_ref in enumerate(zmp_reference[1:]):\r\n                if i < len(self.K_preview):\r\n                    preview_control += self.K_preview[i] * future_ref\r\n\r\n        total_control = feedback_control + preview_control\r\n\r\n        # Convert to CoM acceleration reference\r\n        com_acc_ref = self.omega**2 * (current_com[0] - reference_zmp) + total_control\r\n\r\n        return com_acc_ref\r\n\r\n    def generate_zmp_reference(self, footsteps, step_time=0.8):\r\n        """\r\n        Generate ZMP reference trajectory from footsteps\r\n        """\r\n        dt = self.dt\r\n        step_samples = int(step_time / dt)\r\n        n_steps = len(footsteps)\r\n\r\n        # Create ZMP reference that follows footsteps with smooth transitions\r\n        zmp_ref = np.zeros((n_steps * step_samples, 2))\r\n\r\n        for i, footstep in enumerate(footsteps):\r\n            start_idx = i * step_samples\r\n            end_idx = min((i + 1) * step_samples, len(zmp_ref))\r\n\r\n            # Position of supporting foot\r\n            foot_pos = footstep[\'position\'][:2]\r\n\r\n            # Smooth transition between footsteps\r\n            for j in range(start_idx, end_idx):\r\n                if j < start_idx + step_samples // 5:  # 20% double support\r\n                    # If not first step, interpolate with previous foot position\r\n                    if i > 0:\r\n                        prev_pos = footsteps[i-1][\'position\'][:2]\r\n                        alpha = (j - start_idx) / (step_samples // 5)\r\n                        zmp_ref[j] = (1 - alpha) * prev_pos + alpha * foot_pos\r\n                    else:\r\n                        zmp_ref[j] = foot_pos\r\n                else:\r\n                    zmp_ref[j] = foot_pos\r\n\r\n        return zmp_ref\n'})}),"\n",(0,o.jsx)(n.h2,{id:"walking-pattern-generators",children:"Walking Pattern Generators"}),"\n",(0,o.jsx)(n.h3,{id:"foot-trajectory-generation",children:"Foot Trajectory Generation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class FootTrajectoryGenerator:\r\n    def __init__(self, foot_height=0.1, swing_time_ratio=0.3):\r\n        self.foot_height = foot_height  # Maximum foot lift height\r\n        self.swing_time_ratio = swing_time_ratio  # Ratio of step time for swing phase\r\n\r\n    def generate_foot_trajectory(self, start_pos, end_pos, step_time=0.8, dt=0.01):\r\n        """\r\n        Generate complete foot trajectory for one step\r\n        """\r\n        total_samples = int(step_time / dt)\r\n        trajectory = np.zeros((total_samples, 6))  # Position and velocity (x, y, z)\r\n\r\n        # Calculate swing and stance phases\r\n        swing_samples = int(total_samples * self.swing_time_ratio)\r\n        stance_samples = total_samples - swing_samples\r\n\r\n        # Generate trajectory using 5th order polynomial for smooth motion\r\n        for i in range(3):  # For x, y, z\r\n            if i < 2:  # X and Y (horizontal movement)\r\n                # Only move during swing phase\r\n                swing_traj = self.generate_5th_order_polynomial(\r\n                    start_pos[i], 0, 0,  # Start: pos, vel, acc\r\n                    end_pos[i], 0, 0,    # End: pos, vel, acc\r\n                    swing_samples\r\n                )\r\n\r\n                # Combine with stance phase (no movement)\r\n                full_traj = np.zeros(total_samples)\r\n                full_traj[:swing_samples] = swing_traj\r\n                full_traj[swing_samples:] = end_pos[i]  # Hold position during stance\r\n\r\n            else:  # Z (vertical movement)\r\n                # Foot lifts during swing, stays low during stance\r\n                swing_z = self.generate_vertical_profile(swing_samples)\r\n                stance_z = np.full(stance_samples, start_pos[2])  # Maintain ground contact height\r\n\r\n                full_traj = np.concatenate([swing_z, stance_z])\r\n\r\n            trajectory[:, i] = full_traj\r\n\r\n        # Calculate velocities (numerical differentiation)\r\n        for i in range(3):\r\n            trajectory[:, i + 3] = np.gradient(trajectory[:, i], dt)\r\n\r\n        return trajectory\r\n\r\n    def generate_5th_order_polynomial(self, x0, v0, a0, x1, v1, a1, n_points):\r\n        """\r\n        Generate 5th order polynomial trajectory\r\n        """\r\n        t = np.linspace(0, 1, n_points)\r\n\r\n        # Coefficients for 5th order polynomial: x(t) = a0 + a1*t + a2*t^2 + a3*t^3 + a4*t^4 + a5*t^5\r\n        A = np.array([\r\n            [1, 0, 0, 0, 0, 0],\r\n            [0, 1, 0, 0, 0, 0],\r\n            [0, 0, 2, 0, 0, 0],\r\n            [1, 1, 1, 1, 1, 1],\r\n            [0, 1, 2, 3, 4, 5],\r\n            [0, 0, 2, 6, 12, 20]\r\n        ])\r\n\r\n        b = np.array([x0, v0, a0, x1, v1, a1])\r\n        coeffs = np.linalg.solve(A, b)\r\n\r\n        # Evaluate polynomial\r\n        traj = (coeffs[0] + coeffs[1]*t + coeffs[2]*t**2 +\r\n                coeffs[3]*t**3 + coeffs[4]*t**4 + coeffs[5]*t**5)\r\n\r\n        return traj\r\n\r\n    def generate_vertical_profile(self, swing_samples):\r\n        """\r\n        Generate vertical foot trajectory for swing phase\r\n        """\r\n        # Create a smooth profile that lifts foot and puts it down\r\n        t = np.linspace(0, 1, swing_samples)\r\n\r\n        # Use 5th order polynomial for smooth lift and place\r\n        lift_height = self.foot_height\r\n        start_z = 0  # Foot starts at ground level\r\n        end_z = 0    # Foot ends at ground level\r\n\r\n        # Generate polynomial coefficients for vertical motion\r\n        A = np.array([\r\n            [1, 0, 0, 0, 0, 0],    # Start position\r\n            [0, 1, 0, 0, 0, 0],    # Start velocity\r\n            [0, 0, 2, 0, 0, 0],    # Start acceleration\r\n            [1, 1, 1, 1, 1, 1],    # End position\r\n            [0, 1, 2, 3, 4, 5],    # End velocity\r\n            [0, 0, 2, 6, 12, 20]   # End acceleration\r\n        ])\r\n\r\n        b = np.array([start_z, 0, 0, end_z, 0, 0])  # Zero velocity and acceleration at start/end\r\n        coeffs = np.linalg.solve(A, b)\r\n\r\n        # Evaluate polynomial for vertical trajectory\r\n        z_traj = (coeffs[0] + coeffs[1]*t + coeffs[2]*t**2 +\r\n                 coeffs[3]*t**3 + coeffs[4]*t**4 + coeffs[5]*t**5)\r\n\r\n        # Scale to achieve desired lift height\r\n        max_z = np.max(z_traj)\r\n        if max_z > 0:\r\n            z_traj = z_traj * (lift_height / max_z)\r\n\r\n        return z_traj\r\n\r\n    def generate_ankle_trajectory(self, foot_trajectory):\r\n        """\r\n        Generate ankle trajectory from foot trajectory\r\n        """\r\n        # For simplicity, ankle trajectory follows foot trajectory\r\n        # In reality, ankle trajectory would consider foot orientation and ground contact\r\n        return foot_trajectory\n'})}),"\n",(0,o.jsx)(n.h2,{id:"walking-controllers",children:"Walking Controllers"}),"\n",(0,o.jsx)(n.h3,{id:"joint-space-walking-controller",children:"Joint Space Walking Controller"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class WalkingController:\r\n    def __init__(self, robot_model, zmp_controller, preview_controller):\r\n        self.model = robot_model\r\n        self.zmp_controller = zmp_controller\r\n        self.preview_controller = preview_controller\r\n        self.foot_generator = FootTrajectoryGenerator()\r\n\r\n        # Walking parameters\r\n        self.step_length = 0.3\r\n        self.step_width = 0.2\r\n        self.step_time = 0.8\r\n        self.com_height = 0.8\r\n\r\n        # Initialize walking state\r\n        self.current_step = 0\r\n        self.is_left_support = True  # Start with left foot as support\r\n        self.walking_state = "double_support"  # Initial state\r\n\r\n    def compute_walking_control(self, current_state, dt=0.01):\r\n        """\r\n        Compute walking control for current state\r\n        """\r\n        # 1. Update ZMP and CoM based on current state\r\n        com_pos = current_state[\'com_pos\']\r\n        com_vel = current_state[\'com_vel\']\r\n        com_acc = current_state[\'com_acc\']\r\n\r\n        current_zmp = self.zmp_controller.calculate_zmp_from_com(com_pos, com_vel, com_acc)\r\n\r\n        # 2. Plan next footsteps\r\n        next_footsteps = self.plan_next_footsteps(current_state)\r\n\r\n        # 3. Generate ZMP reference\r\n        zmp_reference = self.preview_controller.generate_zmp_reference(next_footsteps)\r\n\r\n        # 4. Compute CoM control using preview control\r\n        com_control = self.preview_controller.compute_control(com_pos, com_vel, zmp_reference[0])\r\n\r\n        # 5. Generate foot trajectories\r\n        left_foot_traj, right_foot_traj = self.generate_foot_trajectories(\r\n            current_state, next_footsteps\r\n        )\r\n\r\n        # 6. Compute joint space control\r\n        joint_torques = self.compute_joint_control(\r\n            current_state, com_control, left_foot_traj, right_foot_traj\r\n        )\r\n\r\n        # 7. Update walking state\r\n        self.update_walking_state(current_state)\r\n\r\n        return {\r\n            \'joint_torques\': joint_torques,\r\n            \'com_control\': com_control,\r\n            \'zmp_reference\': zmp_reference[0],\r\n            \'current_zmp\': current_zmp\r\n        }\r\n\r\n    def plan_next_footsteps(self, current_state):\r\n        """\r\n        Plan next few footsteps based on current state and desired walking direction\r\n        """\r\n        # For this example, plan a simple forward walk\r\n        # In practice, this would consider terrain, obstacles, and walking goals\r\n        current_pos = current_state[\'base_pos\'][:2]  # X, Y position\r\n        current_heading = current_state[\'base_pos\'][2]  # Yaw angle\r\n\r\n        footsteps = []\r\n        n_future_steps = 3  # Plan 3 steps ahead\r\n\r\n        for i in range(n_future_steps):\r\n            step_x = current_pos[0] + (i + 1) * self.step_length * np.cos(current_heading)\r\n            step_y = current_pos[1] + (i + 1) * self.step_length * np.sin(current_heading)\r\n\r\n            # Alternate feet\r\n            is_left = (self.current_step + i) % 2 == 0\r\n            if is_left:\r\n                step_y += self.step_width / 2 * np.cos(current_heading + np.pi/2)\r\n            else:\r\n                step_y += self.step_width / 2 * np.cos(current_heading - np.pi/2)\r\n\r\n            step_theta = current_heading  # Maintain heading\r\n\r\n            footsteps.append({\r\n                \'position\': np.array([step_x, step_y, step_theta]),\r\n                \'is_left\': is_left,\r\n                \'step_number\': self.current_step + i\r\n            })\r\n\r\n        return footsteps\r\n\r\n    def generate_foot_trajectories(self, current_state, footsteps):\r\n        """\r\n        Generate complete foot trajectories for next steps\r\n        """\r\n        # Get current foot positions\r\n        left_foot_pos = current_state[\'left_foot_pos\']\r\n        right_foot_pos = current_state[\'right_foot_pos\']\r\n\r\n        # Determine which foot is swing foot\r\n        swing_foot_pos = left_foot_pos if not self.is_left_support else right_foot_pos\r\n        stance_foot_pos = right_foot_pos if not self.is_left_support else left_foot_pos\r\n\r\n        # Generate trajectory for swing foot\r\n        next_footstep = footsteps[0]  # Next target footstep\r\n        swing_trajectory = self.foot_generator.generate_foot_trajectory(\r\n            swing_foot_pos, next_footstep[\'position\'], self.step_time\r\n        )\r\n\r\n        # Stance foot remains in place (for now)\r\n        stance_trajectory = np.tile(stance_foot_pos, (len(swing_trajectory), 1))\r\n\r\n        if self.is_left_support:\r\n            left_foot_traj = stance_trajectory\r\n            right_foot_traj = swing_trajectory\r\n        else:\r\n            left_foot_traj = swing_trajectory\r\n            right_foot_traj = stance_trajectory\r\n\r\n        return left_foot_traj[0], right_foot_traj[0]  # Return first point for current control\r\n\r\n    def compute_joint_control(self, current_state, com_control, left_foot_ref, right_foot_ref):\r\n        """\r\n        Compute joint space control using operational space control\r\n        """\r\n        # Get current joint positions and velocities\r\n        q = current_state[\'joint_positions\']\r\n        qd = current_state[\'joint_velocities\']\r\n\r\n        # Compute Jacobians for feet and CoM\r\n        left_foot_jac = self.model.get_jacobian(\'left_foot\', q)\r\n        right_foot_jac = self.model.get_jacobian(\'right_foot\', q)\r\n        com_jac = self.model.get_com_jacobian(q)\r\n\r\n        # Mass matrix\r\n        M = self.model.mass_matrix(q)\r\n\r\n        # Desired accelerations\r\n        left_foot_acc_des = self.compute_foot_acceleration(left_foot_ref)\r\n        right_foot_acc_des = self.compute_foot_acceleration(right_foot_ref)\r\n        com_acc_des = np.array([com_control, 0, 0])  # Simplified - only x-direction control\r\n\r\n        # Stack task equations\r\n        # For simplicity, we\'ll focus on CoM control and one foot (stance foot)\r\n        if self.is_left_support:\r\n            # Control right foot (swing) and CoM\r\n            task_jac = np.vstack([right_foot_jac, com_jac[:3, :]])  # Only position part of CoM\r\n            task_acc_des = np.hstack([left_foot_acc_des[:3], com_acc_des[:3]])  # Only position\r\n        else:\r\n            # Control left foot (swing) and CoM\r\n            task_jac = np.vstack([left_foot_jac, com_jac[:3, :]])\r\n            task_acc_des = np.hstack([right_foot_acc_des[:3], com_acc_des[:3]])\r\n\r\n        # Operational space control law\r\n        Lambda = np.linalg.inv(task_jac @ np.linalg.inv(M) @ task_jac.T)\r\n        J_bar = np.linalg.inv(M) @ task_jac.T @ Lambda  # Dynamically consistent inverse\r\n\r\n        # Compute task-space forces\r\n        Kp_pos = 100 * np.eye(task_acc_des.shape[0])  # Position gains\r\n        Kd_vel = 20 * np.eye(task_acc_des.shape[0])   # Velocity gains\r\n\r\n        task_error = self.compute_task_error(q, task_jac)  # Simplified\r\n        task_vel_error = self.compute_task_velocity_error(q, qd, task_jac)  # Simplified\r\n\r\n        F_task = Lambda @ (task_acc_des + Kp_pos @ task_error + Kd_vel @ task_vel_error)\r\n\r\n        # Convert to joint torques\r\n        tau = task_jac.T @ F_task\r\n\r\n        # Add null-space motion to maintain posture\r\n        tau += self.compute_null_space_motion(q, qd, M, task_jac)\r\n\r\n        return tau\r\n\r\n    def compute_foot_acceleration(self, foot_ref):\r\n        """\r\n        Compute desired foot acceleration from reference trajectory\r\n        """\r\n        # Simplified - in practice, this would use trajectory derivatives\r\n        return np.zeros(6)  # [xdot, ydot, zdot, xddot, yddot, zddot]\r\n\r\n    def compute_task_error(self, q, jacobian):\r\n        """\r\n        Compute task space position error\r\n        """\r\n        # Simplified implementation\r\n        return np.zeros(jacobian.shape[0])\r\n\r\n    def compute_task_velocity_error(self, q, qd, jacobian):\r\n        """\r\n        Compute task space velocity error\r\n        """\r\n        # Simplified implementation\r\n        return np.zeros(jacobian.shape[0])\r\n\r\n    def compute_null_space_motion(self, q, qd, M, task_jac):\r\n        """\r\n        Compute motion in null space to achieve secondary objectives\r\n        """\r\n        # Null space projector\r\n        J_bar = np.linalg.pinv(task_jac)  # Pseudo-inverse\r\n        I = np.eye(M.shape[0])\r\n        N = I - J_bar @ task_jac\r\n\r\n        # Desired null space motion (e.g., toward nominal posture)\r\n        q_nominal = np.array([0, 0.1, -0.2, 0.1, 0, 0, 0] * 2)  # Simplified nominal pose\r\n        null_motion = 0.1 * (q_nominal - q)\r\n\r\n        return N.T @ null_motion\r\n\r\n    def update_walking_state(self, current_state):\r\n        """\r\n        Update walking state based on phase and foot contacts\r\n        """\r\n        # Simplified state machine\r\n        time_in_step = current_state.get(\'time_in_step\', 0)\r\n        step_phase = time_in_step / self.step_time\r\n\r\n        if step_phase < 0.1:  # First 10% of step\r\n            self.walking_state = "double_support"\r\n        elif step_phase < 0.9:  # Middle 80% of step\r\n            self.walking_state = "single_support"\r\n        else:  # Last 10% of step\r\n            self.walking_state = "double_support"\r\n\r\n        # Update support foot\r\n        if step_phase > 0.5 and self.walking_state == "single_support":\r\n            self.is_left_support = not self.is_left_support  # Switch support foot\r\n            self.current_step += 1\n'})}),"\n",(0,o.jsx)(n.h2,{id:"advanced-walking-techniques",children:"Advanced Walking Techniques"}),"\n",(0,o.jsx)(n.h3,{id:"walking-on-uneven-terrain",children:"Walking on Uneven Terrain"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class UnevenTerrainWalker:\r\n    def __init__(self, base_walker):\r\n        self.base_walker = base_walker\r\n        self.terrain_estimator = self.initialize_terrain_estimator()\r\n\r\n    def initialize_terrain_estimator(self):\r\n        """\r\n        Initialize terrain estimation system\r\n        """\r\n        return {\r\n            \'height_map\': np.zeros((100, 100)),  # Local height map\r\n            \'obstacle_map\': np.zeros((100, 100)),  # Obstacle map\r\n            \'roughness_map\': np.zeros((100, 100))  # Surface roughness\r\n        }\r\n\r\n    def adapt_walking_for_terrain(self, current_state, terrain_data):\r\n        """\r\n        Adapt walking pattern based on terrain characteristics\r\n        """\r\n        # 1. Update terrain model\r\n        self.update_terrain_model(terrain_data)\r\n\r\n        # 2. Adjust footstep placement\r\n        adjusted_footsteps = self.adjust_footsteps_for_terrain(\r\n            current_state, terrain_data\r\n        )\r\n\r\n        # 3. Modify ZMP reference\r\n        modified_zmp_ref = self.modify_zmp_for_terrain(\r\n            current_state, terrain_data\r\n        )\r\n\r\n        # 4. Adjust walking parameters\r\n        modified_params = self.adjust_walking_parameters(\r\n            terrain_data\r\n        )\r\n\r\n        # 5. Generate adapted control\r\n        control_commands = self.base_walker.compute_walking_control(\r\n            current_state\r\n        )\r\n\r\n        # 6. Apply terrain-specific modifications\r\n        adapted_control = self.apply_terrain_adaptations(\r\n            control_commands, terrain_data\r\n        )\r\n\r\n        return adapted_control\r\n\r\n    def update_terrain_model(self, terrain_data):\r\n        """\r\n        Update internal terrain model with new sensor data\r\n        """\r\n        # Update height map with new LIDAR or vision data\r\n        # Update obstacle map\r\n        # Update roughness estimates\r\n        pass\r\n\r\n    def adjust_footsteps_for_terrain(self, current_state, terrain_data):\r\n        """\r\n        Adjust footstep locations based on terrain characteristics\r\n        """\r\n        original_footsteps = self.base_walker.plan_next_footsteps(current_state)\r\n\r\n        adjusted_footsteps = []\r\n        for footstep in original_footsteps:\r\n            original_pos = footstep[\'position\']\r\n\r\n            # Check terrain at original location\r\n            terrain_height = self.get_terrain_height(original_pos[:2])\r\n            terrain_roughness = self.get_terrain_roughness(original_pos[:2])\r\n            has_obstacle = self.has_obstacle_at(original_pos[:2])\r\n\r\n            adjusted_pos = original_pos.copy()\r\n\r\n            if has_obstacle:\r\n                # Find alternative location\r\n                adjusted_pos = self.find_safe_alternative(footstep, terrain_data)\r\n            elif terrain_roughness > 0.05:  # Too rough\r\n                # Adjust foot orientation or position\r\n                adjusted_pos = self.adjust_for_roughness(footstep, terrain_data)\r\n            elif abs(terrain_height - current_state[\'base_pos\'][2]) > 0.1:  # Height change > 10cm\r\n                # Adjust step height or approach\r\n                adjusted_pos = self.adjust_for_height_change(footstep, terrain_data)\r\n\r\n            adjusted_footsteps.append({\r\n                \'position\': adjusted_pos,\r\n                \'is_left\': footstep[\'is_left\'],\r\n                \'step_number\': footstep[\'step_number\']\r\n            })\r\n\r\n        return adjusted_footsteps\r\n\r\n    def modify_zmp_for_terrain(self, current_state, terrain_data):\r\n        """\r\n        Modify ZMP reference for terrain adaptation\r\n        """\r\n        # On slopes, adjust ZMP to maintain stability\r\n        # On rough terrain, use more conservative ZMP bounds\r\n        # On stairs, adjust for step height\r\n        pass\r\n\r\n    def adjust_walking_parameters(self, terrain_data):\r\n        """\r\n        Adjust walking parameters based on terrain\r\n        """\r\n        params = {\r\n            \'step_length\': self.step_length,\r\n            \'step_width\': self.step_width,\r\n            \'step_time\': self.step_time,\r\n            \'foot_lift_height\': self.foot_generator.foot_height\r\n        }\r\n\r\n        # Adjust for different terrain types\r\n        terrain_type = self.classify_terrain(terrain_data)\r\n\r\n        if terrain_type == \'slope_up\':\r\n            params[\'step_length\'] *= 0.8  # Shorter steps on uphill\r\n            params[\'step_time\'] *= 1.2   # Slower on uphill\r\n        elif terrain_type == \'slope_down\':\r\n            params[\'step_length\'] *= 0.9  # Shorter steps on downhill\r\n            params[\'step_time\'] *= 1.1   # More cautious downhill\r\n        elif terrain_type == \'rough\':\r\n            params[\'step_time\'] *= 1.3   # Slower on rough terrain\r\n            params[\'foot_lift_height\'] *= 1.5  # Higher foot lift\r\n        elif terrain_type == \'stairs\':\r\n            # Special stair climbing gait\r\n            pass\r\n\r\n        return params\r\n\r\n    def apply_terrain_adaptations(self, control_commands, terrain_data):\r\n        """\r\n        Apply terrain-specific modifications to control commands\r\n        """\r\n        # Add ankle adjustments for uneven terrain\r\n        # Modify hip height for step climbing\r\n        # Adjust balance strategy for different surfaces\r\n        return control_commands\r\n\r\n    def get_terrain_height(self, position):\r\n        """\r\n        Get terrain height at given position\r\n        """\r\n        # Interpolate from height map\r\n        return 0.0\r\n\r\n    def get_terrain_roughness(self, position):\r\n        """\r\n        Get terrain roughness at given position\r\n        """\r\n        # Calculate from local height variations\r\n        return 0.0\r\n\r\n    def has_obstacle_at(self, position):\r\n        """\r\n        Check if there\'s an obstacle at given position\r\n        """\r\n        return False\r\n\r\n    def find_safe_alternative(self, footstep, terrain_data):\r\n        """\r\n        Find safe alternative footstep location\r\n        """\r\n        # Search in local neighborhood for safe placement\r\n        return footstep[\'position\']\n'})}),"\n",(0,o.jsx)(n.h2,{id:"walking-stability-and-recovery",children:"Walking Stability and Recovery"}),"\n",(0,o.jsx)(n.h3,{id:"disturbance-recovery",children:"Disturbance Recovery"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class DisturbanceRecovery:\r\n    def __init__(self, robot_model):\r\n        self.model = robot_model\r\n        self.capturability = self.calculate_capturability()\r\n\r\n    def calculate_capturability(self):\r\n        \"\"\"\r\n        Calculate capturability region for the robot\r\n        \"\"\"\r\n        # The capturability region defines where the robot can step to stop\r\n        # This is based on the Linear Inverted Pendulum Model\r\n        com_height = 0.8  # Example CoM height\r\n        g = 9.81\r\n        omega = np.sqrt(g / com_height)\r\n\r\n        # Maximum step time for recovery\r\n        max_time = 2.0  # seconds\r\n\r\n        # Maximum recoverable velocity\r\n        max_velocity = 0.5  # m/s\r\n\r\n        return {\r\n            'max_distance': omega * max_time,  # Maximum distance to capture point\r\n            'max_velocity': max_velocity,\r\n            'omega': omega\r\n        }\r\n\r\n    def detect_disturbance(self, current_state, threshold=0.1):\r\n        \"\"\"\r\n        Detect if robot is experiencing a disturbance\r\n        \"\"\"\r\n        zmp_pos = current_state['zmp']\r\n        support_polygon = current_state['support_polygon']\r\n\r\n        # Check if ZMP is outside support polygon\r\n        zmp_stable = self.model.zmp_controller.is_zmp_stable(zmp_pos, support_polygon)\r\n\r\n        # Check CoM velocity (too fast indicates disturbance)\r\n        com_velocity_norm = np.linalg.norm(current_state['com_vel'])\r\n\r\n        # Check joint accelerations (sudden changes indicate disturbance)\r\n        joint_acc_norm = np.linalg.norm(current_state['joint_acc'])\r\n\r\n        disturbance_detected = not zmp_stable or \\\r\n                              com_velocity_norm > self.capturability['max_velocity'] or \\\r\n                              joint_acc_norm > threshold\r\n\r\n        return disturbance_detected\r\n\r\n    def compute_recovery_strategy(self, current_state):\r\n        \"\"\"\r\n        Compute recovery strategy based on current state\r\n        \"\"\"\r\n        com_pos = current_state['com_pos'][:2]  # X, Y only\r\n        com_vel = current_state['com_vel'][:2]\r\n\r\n        # Calculate capture point\r\n        capture_point = com_pos + com_vel / self.capturability['omega']\r\n\r\n        # Determine recovery type based on capturability\r\n        distance_to_capture = np.linalg.norm(capture_point - current_state['current_foot_pos'][:2])\r\n\r\n        if distance_to_capture < 0.3:  # Can step to capture point\r\n            return self.step_to_capture_point(current_state, capture_point)\r\n        elif distance_to_capture < 0.6:  # Extended step possible\r\n            return self.extended_step_strategy(current_state, capture_point)\r\n        else:  # May need more aggressive recovery\r\n            return self.emergency_recovery(current_state)\r\n\r\n    def step_to_capture_point(self, current_state, capture_point):\r\n        \"\"\"\r\n        Plan step to capture point for recovery\r\n        \"\"\"\r\n        current_pos = current_state['base_pos'][:2]\r\n\r\n        # Plan step toward capture point\r\n        step_direction = capture_point - current_pos\r\n        step_distance = np.linalg.norm(step_direction)\r\n\r\n        if step_distance > 0:\r\n            step_direction = step_direction / step_distance\r\n            # Limit step size to maximum step length\r\n            step_length = min(step_distance, 0.4)  # Max 40cm step\r\n            target_pos = current_pos + step_length * step_direction\r\n        else:\r\n            target_pos = current_pos\r\n\r\n        return {\r\n            'type': 'capture_point_step',\r\n            'target_position': target_pos,\r\n            'step_timing': 'immediate'\r\n        }\r\n\r\n    def extended_step_strategy(self, current_state, capture_point):\r\n        \"\"\"\r\n        Strategy for when capture point is slightly out of reach\r\n        \"\"\"\r\n        # Use hip shift, arm swing, or extended step\r\n        return {\r\n            'type': 'extended_strategy',\r\n            'target_position': capture_point,\r\n            'modifications': ['hip_shift', 'arm_swing'],\r\n            'timing': 'next_step'\r\n        }\r\n\r\n    def emergency_recovery(self, current_state):\r\n        \"\"\"\r\n        Emergency recovery when falling is imminent\r\n        \"\"\"\r\n        # Strategies: knee bending, arm extension, fall preparation\r\n        return {\r\n            'type': 'emergency',\r\n            'actions': ['bend_knees', 'extend_arms', 'prepare_fall'],\r\n            'priority': 'highest'\r\n        }\r\n\r\n    def execute_recovery(self, recovery_strategy, current_state):\r\n        \"\"\"\r\n        Execute the recovery strategy\r\n        \"\"\"\r\n        if recovery_strategy['type'] == 'capture_point_step':\r\n            # Modify next footstep to target capture point\r\n            return self.modify_footstep_for_recovery(\r\n                current_state, recovery_strategy['target_position']\r\n            )\r\n        elif recovery_strategy['type'] == 'extended_strategy':\r\n            # Apply additional stabilization\r\n            return self.apply_extended_stabilization(\r\n                current_state, recovery_strategy\r\n            )\r\n        elif recovery_strategy['type'] == 'emergency':\r\n            # Execute emergency procedures\r\n            return self.execute_emergency_procedures(\r\n                current_state, recovery_strategy\r\n            )\r\n\r\n        return None\n"})}),"\n",(0,o.jsx)(n.h2,{id:"walking-simulation-and-testing",children:"Walking Simulation and Testing"}),"\n",(0,o.jsx)(n.h3,{id:"walking-simulation-environment",children:"Walking Simulation Environment"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class WalkingSimulator:\r\n    def __init__(self, robot_model, controller):\r\n        self.model = robot_model\r\n        self.controller = controller\r\n        self.dt = 0.01  # 100Hz control rate\r\n\r\n    def simulate_walking_step(self, initial_state, steps=10):\r\n        \"\"\"\r\n        Simulate walking for specified number of steps\r\n        \"\"\"\r\n        state = initial_state.copy()\r\n        simulation_data = {\r\n            'time': [],\r\n            'com_trajectory': [],\r\n            'zmp_trajectory': [],\r\n            'joint_angles': [],\r\n            'joint_torques': [],\r\n            'foot_positions': []\r\n        }\r\n\r\n        for step in range(steps):\r\n            step_start_time = len(simulation_data['time']) * self.dt\r\n\r\n            # Simulate one step duration\r\n            step_duration = 0.8  # 800ms per step\r\n            step_samples = int(step_duration / self.dt)\r\n\r\n            for i in range(step_samples):\r\n                current_time = step_start_time + i * self.dt\r\n\r\n                # Get sensor data from current state\r\n                sensor_data = self.get_sensor_data(state)\r\n\r\n                # Compute control commands\r\n                control_output = self.controller.compute_walking_control(sensor_data, self.dt)\r\n\r\n                # Apply control to robot dynamics\r\n                state = self.apply_control_and_update_dynamics(state, control_output['joint_torques'])\r\n\r\n                # Log simulation data\r\n                simulation_data['time'].append(current_time)\r\n                simulation_data['com_trajectory'].append(state['com_pos'].copy())\r\n                simulation_data['zmp_trajectory'].append(\r\n                    self.model.zmp_controller.calculate_zmp_from_com(\r\n                        state['com_pos'], state['com_vel'], state['com_acc']\r\n                    )\r\n                )\r\n                simulation_data['joint_angles'].append(state['joint_positions'].copy())\r\n                simulation_data['joint_torques'].append(control_output['joint_torques'].copy())\r\n                simulation_data['foot_positions'].append({\r\n                    'left': state['left_foot_pos'].copy(),\r\n                    'right': state['right_foot_pos'].copy()\r\n                })\r\n\r\n                # Check for stability\r\n                if self.is_falling(state):\r\n                    print(f\"Robot fell at time {current_time:.2f}s\")\r\n                    break\r\n\r\n        return simulation_data\r\n\r\n    def get_sensor_data(self, state):\r\n        \"\"\"\r\n        Simulate sensor data from robot state\r\n        \"\"\"\r\n        # Add realistic sensor noise\r\n        noisy_com_pos = state['com_pos'] + np.random.normal(0, 0.001, 3)\r\n        noisy_com_vel = state['com_vel'] + np.random.normal(0, 0.01, 3)\r\n\r\n        # Simulate IMU data\r\n        imu_data = self.simulate_imu(state)\r\n\r\n        # Simulate joint encoders with noise\r\n        noisy_joint_pos = state['joint_positions'] + np.random.normal(0, 0.0005, len(state['joint_positions']))\r\n\r\n        return {\r\n            'com_pos': noisy_com_pos,\r\n            'com_vel': noisy_com_vel,\r\n            'joint_positions': noisy_joint_pos,\r\n            'joint_velocities': state['joint_velocities'],\r\n            'imu_data': imu_data,\r\n            'force_torque': self.simulate_force_sensors(state)\r\n        }\r\n\r\n    def apply_control_and_update_dynamics(self, state, joint_torques):\r\n        \"\"\"\r\n        Apply control torques and update robot dynamics\r\n        \"\"\"\r\n        # Get current state\r\n        q = state['joint_positions']\r\n        qd = state['joint_velocities']\r\n\r\n        # Get dynamic parameters\r\n        M = self.model.mass_matrix(q)\r\n        C = self.model.coriolis_matrix(q, qd)\r\n        g = self.model.gravity_vector(q)\r\n\r\n        # Compute joint accelerations: M*qdd + C*qd + g = tau\r\n        qdd = np.linalg.solve(M, joint_torques - C @ qd - g)\r\n\r\n        # Integrate to get new velocities and positions\r\n        new_qd = qd + qdd * self.dt\r\n        new_q = q + new_qd * self.dt\r\n\r\n        # Update state\r\n        new_state = state.copy()\r\n        new_state['joint_positions'] = new_q\r\n        new_state['joint_velocities'] = new_qd\r\n\r\n        # Update CoM based on new joint configuration\r\n        new_state['com_pos'] = self.model.calculate_com_position(new_q)\r\n        new_state['com_vel'] = self.model.calculate_com_velocity(new_q, new_qd)\r\n        new_state['com_acc'] = (new_state['com_vel'] - state['com_vel']) / self.dt\r\n\r\n        return new_state\r\n\r\n    def simulate_imu(self, state):\r\n        \"\"\"\r\n        Simulate IMU data\r\n        \"\"\"\r\n        # Calculate body acceleration and angular velocity\r\n        return {\r\n            'linear_acceleration': np.array([0, 0, -9.81]) + np.random.normal(0, 0.01, 3),\r\n            'angular_velocity': state['base_angular_vel'] + np.random.normal(0, 0.001, 3),\r\n            'orientation': state['base_orientation']\r\n        }\r\n\r\n    def simulate_force_sensors(self, state):\r\n        \"\"\"\r\n        Simulate force/torque sensors in feet\r\n        \"\"\"\r\n        # Calculate ground reaction forces based on contact model\r\n        left_contact = self.is_foot_in_contact(state['left_foot_pos'], state['com_pos'])\r\n        right_contact = self.is_foot_in_contact(state['right_foot_pos'], state['com_pos'])\r\n\r\n        # Simplified force calculation\r\n        total_weight = 70 * 9.81  # 70kg robot\r\n\r\n        if left_contact and right_contact:\r\n            # Double support - distribute weight\r\n            left_force = total_weight / 2\r\n            right_force = total_weight / 2\r\n        elif left_contact:\r\n            # Left foot support\r\n            left_force = total_weight\r\n            right_force = 0\r\n        elif right_contact:\r\n            # Right foot support\r\n            left_force = 0\r\n            right_force = total_weight\r\n        else:\r\n            # No contact - robot is falling\r\n            left_force = 0\r\n            right_force = 0\r\n\r\n        return {\r\n            'left_foot': [0, 0, left_force],  # Fx, Fy, Fz\r\n            'right_foot': [0, 0, right_force]\r\n        }\r\n\r\n    def is_foot_in_contact(self, foot_pos, com_pos):\r\n        \"\"\"\r\n        Simple contact detection\r\n        \"\"\"\r\n        # Check if foot is below or at ground level\r\n        return foot_pos[2] <= 0.01  # 1cm above ground considered contact\r\n\r\n    def is_falling(self, state):\r\n        \"\"\"\r\n        Check if robot is falling\r\n        \"\"\"\r\n        # Check if CoM is too far from support polygon\r\n        # Check if joint limits are exceeded\r\n        # Check if robot orientation is too tilted\r\n        base_orientation = state['base_orientation']\r\n        roll, pitch, yaw = self.quaternion_to_euler(base_orientation)\r\n\r\n        return abs(roll) > 0.5 or abs(pitch) > 0.5  # 30 degrees threshold\r\n\r\n    def quaternion_to_euler(self, quat):\r\n        \"\"\"\r\n        Convert quaternion to Euler angles\r\n        \"\"\"\r\n        # Simplified conversion\r\n        w, x, y, z = quat\r\n        roll = np.arctan2(2*(w*x + y*z), 1 - 2*(x*x + y*y))\r\n        pitch = np.arcsin(2*(w*y - z*x))\r\n        yaw = np.arctan2(2*(w*z + x*y), 1 - 2*(y*y + z*z))\r\n        return roll, pitch, yaw\r\n\r\n    def analyze_walking_performance(self, simulation_data):\r\n        \"\"\"\r\n        Analyze walking performance metrics\r\n        \"\"\"\r\n        metrics = {}\r\n\r\n        # Calculate walking speed\r\n        com_trajectory = np.array(simulation_data['com_trajectory'])\r\n        total_distance = np.sum(np.sqrt(np.sum(np.diff(com_trajectory[:, :2], axis=0)**2, axis=1)))\r\n        total_time = simulation_data['time'][-1] - simulation_data['time'][0]\r\n        avg_speed = total_distance / total_time if total_time > 0 else 0\r\n\r\n        # Calculate ZMP tracking error\r\n        zmp_trajectory = np.array(simulation_data['zmp_trajectory'])\r\n        # Calculate how well ZMP stays within support polygon\r\n        # (This would require support polygon data for each timestep)\r\n\r\n        # Calculate energy efficiency\r\n        joint_torques = np.array(simulation_data['joint_torques'])\r\n        energy_consumption = np.sum(np.abs(joint_torques)) * self.dt\r\n\r\n        metrics = {\r\n            'average_speed': avg_speed,\r\n            'total_distance': total_distance,\r\n            'energy_efficiency': energy_consumption,\r\n            'stability_score': self.calculate_stability_score(simulation_data),\r\n            'step_consistency': self.calculate_step_consistency(simulation_data)\r\n        }\r\n\r\n        return metrics\r\n\r\n    def calculate_stability_score(self, simulation_data):\r\n        \"\"\"\r\n        Calculate stability score based on ZMP tracking\r\n        \"\"\"\r\n        # Simplified stability calculation\r\n        return 0.8  # Placeholder\r\n\r\n    def calculate_step_consistency(self, simulation_data):\r\n        \"\"\"\r\n        Calculate consistency of step patterns\r\n        \"\"\"\r\n        # Simplified consistency calculation\r\n        return 0.9  # Placeholder\n"})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control algorithms that integrate:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pattern Generation"}),": Creating stable CoM and foot trajectories"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ZMP Control"}),": Ensuring the Zero Moment Point stays within the support polygon"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Balance Control"}),": Maintaining stability during dynamic motion"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Terrain Adaptation"}),": Adjusting gait for different surfaces and obstacles"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Disturbance Recovery"}),": Handling unexpected forces and maintaining stability"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The key techniques covered in this section include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CoM trajectory generation"})," using inverted pendulum models"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Footstep planning"})," for various walking patterns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ZMP-based control"})," for stable walking"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Preview control"})," for improved ZMP tracking"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Advanced techniques"})," for uneven terrain and disturbance recovery"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Successful bipedal locomotion requires careful coordination of all these elements, along with real-time state estimation and control adaptation. The next section will focus specifically on balance and postural control, which is essential for stable bipedal locomotion."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(_,{...e})}):_(e)}}}]);