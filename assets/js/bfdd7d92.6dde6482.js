"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[3747],{5623:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module2/physics-sensor-simulation","title":"Physics and Sensor Simulation","description":"Introduction","source":"@site/docs/module2/physics-sensor-simulation.md","sourceDirName":"module2","slug":"/module2/physics-sensor-simulation","permalink":"/Physical-AI-Humanoid-book/docs/module2/physics-sensor-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/user/physical-ai-humanoid-robotics/tree/main/docs/module2/physics-sensor-simulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Practical Lab: Creating Your First Robot Simulation","permalink":"/Physical-AI-Humanoid-book/docs/module2/lab-first-simulation"},"next":{"title":"Unity for Robot Visualization","permalink":"/Physical-AI-Humanoid-book/docs/module2/unity-visualization"}}');var s=i(4848),o=i(8453);const a={},l="Physics and Sensor Simulation",t={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Physics Simulation Fundamentals",id:"physics-simulation-fundamentals",level:2},{value:"Physics Engine Concepts",id:"physics-engine-concepts",level:3},{value:"Physics Configuration in World Files",id:"physics-configuration-in-world-files",level:3},{value:"Physics Parameters Explained",id:"physics-parameters-explained",level:3},{value:"Collision Detection and Geometry",id:"collision-detection-and-geometry",level:2},{value:"Collision Shapes",id:"collision-shapes",level:3},{value:"Surface Properties",id:"surface-properties",level:3},{value:"Inertial Properties",id:"inertial-properties",level:2},{value:"Calculating Inertial Properties",id:"calculating-inertial-properties",level:3},{value:"Joint Dynamics",id:"joint-dynamics",level:2},{value:"Joint Friction and Damping",id:"joint-friction-and-damping",level:3},{value:"Joint Actuators",id:"joint-actuators",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"Camera Sensors",id:"camera-sensors",level:3},{value:"LIDAR Sensors",id:"lidar-sensors",level:3},{value:"IMU Sensors",id:"imu-sensors",level:3},{value:"Force/Torque Sensors",id:"forcetorque-sensors",level:3},{value:"Sensor Noise and Realism",id:"sensor-noise-and-realism",level:2},{value:"Adding Noise to Sensors",id:"adding-noise-to-sensors",level:3},{value:"Common Noise Models",id:"common-noise-models",level:3},{value:"Physics Performance Optimization",id:"physics-performance-optimization",level:2},{value:"Collision Simplification",id:"collision-simplification",level:3},{value:"Contact Reduction",id:"contact-reduction",level:3},{value:"Advanced Physics Concepts",id:"advanced-physics-concepts",level:2},{value:"Multi-Body Dynamics",id:"multi-body-dynamics",level:3},{value:"Soft Body Simulation",id:"soft-body-simulation",level:3},{value:"Sensor Fusion Simulation",id:"sensor-fusion-simulation",level:2},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Physics Instability",id:"physics-instability",level:3},{value:"Sensor Data Issues",id:"sensor-data-issues",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:2},{value:"Physics Validation",id:"physics-validation",level:3},{value:"Sensor Validation",id:"sensor-validation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"physics-and-sensor-simulation",children:"Physics and Sensor Simulation"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Physics and sensor simulation are crucial components of robot simulation that determine how accurately the virtual environment represents real-world conditions. Properly configured physics and sensor models are essential for developing and testing robotic systems that will eventually operate in the physical world."}),"\n",(0,s.jsx)(n.h2,{id:"physics-simulation-fundamentals",children:"Physics Simulation Fundamentals"}),"\n",(0,s.jsx)(n.h3,{id:"physics-engine-concepts",children:"Physics Engine Concepts"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo uses physics engines (like ODE, Bullet, or DART) to simulate the laws of physics in the virtual environment. The physics engine calculates:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Detection"}),": Identifying when objects come into contact"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Response"}),": Determining the resulting forces and motion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamics"}),": Simulating motion based on applied forces and torques"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Constraints"}),": Maintaining joint relationships and limits"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"physics-configuration-in-world-files",children:"Physics Configuration in World Files"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sdf version="1.7">\r\n  <world name="physics_example">\r\n    <physics type="ode">\r\n      \x3c!-- Time step settings --\x3e\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n\r\n      \x3c!-- ODE-specific parameters --\x3e\r\n      <ode>\r\n        <solver>\r\n          <type>quick</type>\r\n          <iters>10</iters>\r\n          <sor>1.3</sor>\r\n        </solver>\r\n        <constraints>\r\n          <cfm>0.0</cfm>\r\n          <erp>0.2</erp>\r\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n          <contact_surface_layer>0.001</contact_surface_layer>\r\n        </constraints>\r\n      </ode>\r\n    </physics>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"physics-parameters-explained",children:"Physics Parameters Explained"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Typical Value"}),(0,s.jsx)(n.th,{children:"Effect"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"max_step_size"}),(0,s.jsx)(n.td,{children:"Simulation time step"}),(0,s.jsx)(n.td,{children:"0.001s"}),(0,s.jsx)(n.td,{children:"Smaller = more accurate but slower"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"real_time_factor"}),(0,s.jsx)(n.td,{children:"Simulation speed"}),(0,s.jsx)(n.td,{children:"1.0"}),(0,s.jsx)(n.td,{children:"1.0 = real-time, >1 = faster"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"iters"}),(0,s.jsx)(n.td,{children:"Solver iterations"}),(0,s.jsx)(n.td,{children:"10-50"}),(0,s.jsx)(n.td,{children:"More iterations = more stable"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"cfm"}),(0,s.jsx)(n.td,{children:"Constraint Force Mixing"}),(0,s.jsx)(n.td,{children:"0.0"}),(0,s.jsx)(n.td,{children:"Affects constraint stiffness"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"erp"}),(0,s.jsx)(n.td,{children:"Error Reduction Parameter"}),(0,s.jsx)(n.td,{children:"0.1-0.8"}),(0,s.jsx)(n.td,{children:"Affects constraint error correction"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"collision-detection-and-geometry",children:"Collision Detection and Geometry"}),"\n",(0,s.jsx)(n.h3,{id:"collision-shapes",children:"Collision Shapes"}),"\n",(0,s.jsx)(n.p,{children:"Different collision geometries offer trade-offs between accuracy and performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="collision_example">\r\n  \x3c!-- Box collision --\x3e\r\n  <collision name="box_collision">\r\n    <geometry>\r\n      <box>\r\n        <size>1.0 0.5 0.3</size>\r\n      </box>\r\n    </geometry>\r\n  </collision>\r\n\r\n  \x3c!-- Cylinder collision --\x3e\r\n  <collision name="cylinder_collision">\r\n    <geometry>\r\n      <cylinder>\r\n        <length>0.5</length>\r\n        <radius>0.2</radius>\r\n      </cylinder>\r\n    </geometry>\r\n  </collision>\r\n\r\n  \x3c!-- Sphere collision --\x3e\r\n  <collision name="sphere_collision">\r\n    <geometry>\r\n      <sphere>\r\n        <radius>0.1</radius>\r\n      </sphere>\r\n    </geometry>\r\n  </collision>\r\n\r\n  \x3c!-- Mesh collision (for complex shapes) --\x3e\r\n  <collision name="mesh_collision">\r\n    <geometry>\r\n      <mesh>\r\n        <uri>model://my_robot/meshes/complex_shape.stl</uri>\r\n      </mesh>\r\n    </geometry>\r\n  </collision>\r\n</link>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"surface-properties",children:"Surface Properties"}),"\n",(0,s.jsx)(n.p,{children:"Surface properties define how objects interact during collisions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="my_link">\r\n  <collision>\r\n    <surface>\r\n      \x3c!-- Friction properties --\x3e\r\n      <friction>\r\n        <ode>\r\n          <mu>1.0</mu>        \x3c!-- Primary friction coefficient --\x3e\r\n          <mu2>1.0</mu2>      \x3c!-- Secondary friction coefficient --\x3e\r\n          <fdir1>0 0 1</fdir1> \x3c!-- Friction direction --\x3e\r\n        </ode>\r\n      </friction>\r\n\r\n      \x3c!-- Contact properties --\x3e\r\n      <contact>\r\n        <ode>\r\n          <soft_cfm>0.0</soft_cfm>     \x3c!-- Soft constraint force mixing --\x3e\r\n          <soft_erp>0.2</soft_erp>     \x3c!-- Soft error reduction parameter --\x3e\r\n          <kp>1e+6</kp>               \x3c!-- Contact stiffness --\x3e\r\n          <kd>1e+3</kd>               \x3c!-- Contact damping --\x3e\r\n          <max_vel>100.0</max_vel>     \x3c!-- Maximum contact correction velocity --\x3e\r\n          <min_depth>0.001</min_depth> \x3c!-- Minimum contact depth --\x3e\r\n        </ode>\r\n      </contact>\r\n\r\n      \x3c!-- Bounce properties --\x3e\r\n      <bounce>\r\n        <restitution_coefficient>0.1</restitution_coefficient>\r\n        <threshold>100000.0</threshold>\r\n      </bounce>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,s.jsx)(n.p,{children:"Accurate inertial properties are crucial for realistic dynamics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="accurate_inertial">\r\n  <inertial>\r\n    <mass>2.5</mass>\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n    <inertia\r\n      ixx="0.025" ixy="0.0" ixz="0.0"\r\n      iyy="0.035" iyz="0.0"\r\n      izz="0.045"/>\r\n  </inertial>\r\n</link>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"calculating-inertial-properties",children:"Calculating Inertial Properties"}),"\n",(0,s.jsx)(n.p,{children:"For common shapes (mass m, dimensions as appropriate):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Box"})," (length a, width b, height c):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ixx = m*(b\xb2 + c\xb2)/12"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"iyy = m*(a\xb2 + c\xb2)/12"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"izz = m*(a\xb2 + b\xb2)/12"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cylinder"})," (radius r, height h):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ixx = m*(3*r\xb2 + h\xb2)/12"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"iyy = m*(3*r\xb2 + h\xb2)/12"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"izz = m*r\xb2/2"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sphere"})," (radius r):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ixx = iyy = izz = 2*m*r\xb2/5"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"joint-dynamics",children:"Joint Dynamics"}),"\n",(0,s.jsx)(n.h3,{id:"joint-friction-and-damping",children:"Joint Friction and Damping"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="joint_with_dynamics" type="revolute">\r\n  <parent link="parent_link"/>\r\n  <child link="child_link"/>\r\n  <axis xyz="0 0 1">\r\n    \x3c!-- Joint limits --\x3e\r\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="2.0"/>\r\n\r\n    \x3c!-- Dynamics properties --\x3e\r\n    <dynamics damping="0.1" friction="0.05"/>\r\n  </axis>\r\n</joint>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"joint-actuators",children:"Joint Actuators"}),"\n",(0,s.jsx)(n.p,{children:"For simulating motor behavior:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo>\r\n  <plugin name="joint_control" filename="libgazebo_ros_effort.so">\r\n    <robotNamespace>/my_robot</robotNamespace>\r\n    <jointName>motor_joint</jointName>\r\n    <topicName>motor/cmd</topicName>\r\n    <updateRate>100</updateRate>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,s.jsx)(n.h3,{id:"camera-sensors",children:"Camera Sensors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="camera_link">\r\n  <sensor name="camera" type="camera">\r\n    <always_on>true</always_on>\r\n    <update_rate>30</update_rate>\r\n    <camera name="head">\r\n      <horizontal_fov>1.3962634</horizontal_fov> \x3c!-- 80 degrees --\x3e\r\n      <image>\r\n        <width>640</width>\r\n        <height>480</height>\r\n        <format>R8G8B8</format>\r\n      </image>\r\n      <clip>\r\n        <near>0.1</near>\r\n        <far>100</far>\r\n      </clip>\r\n    </camera>\r\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\r\n      <frame_name>camera_link</frame_name>\r\n      <topic_name>image_raw</topic_name>\r\n      <hack_baseline>0.07</hack_baseline>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lidar-sensors",children:"LIDAR Sensors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="lidar_link">\r\n  <sensor name="lidar" type="ray">\r\n    <always_on>true</always_on>\r\n    <update_rate>10</update_rate>\r\n    <ray>\r\n      <scan>\r\n        <horizontal>\r\n          <samples>720</samples>\r\n          <resolution>1</resolution>\r\n          <min_angle>-3.14159</min_angle> \x3c!-- -\u03c0 radians --\x3e\r\n          <max_angle>3.14159</max_angle>   \x3c!-- \u03c0 radians --\x3e\r\n        </horizontal>\r\n      </scan>\r\n      <range>\r\n        <min>0.1</min>\r\n        <max>30.0</max>\r\n        <resolution>0.01</resolution>\r\n      </range>\r\n    </ray>\r\n    <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\r\n      <ros>\r\n        <namespace>/my_robot</namespace>\r\n        <remapping>~/out:=scan</remapping>\r\n      </ros>\r\n      <output_type>sensor_msgs/LaserScan</output_type>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"imu-sensors",children:"IMU Sensors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="imu_link">\r\n  <sensor name="imu" type="imu">\r\n    <always_on>true</always_on>\r\n    <update_rate>100</update_rate>\r\n    <imu>\r\n      <angular_velocity>\r\n        <x>\r\n          <noise type="gaussian">\r\n            <mean>0.0</mean>\r\n            <stddev>0.0017</stddev> \x3c!-- ~0.1 deg/s --\x3e\r\n          </noise>\r\n        </x>\r\n        <y>\r\n          <noise type="gaussian">\r\n            <mean>0.0</mean>\r\n            <stddev>0.0017</stddev>\r\n          </noise>\r\n        </y>\r\n        <z>\r\n          <noise type="gaussian">\r\n            <mean>0.0</mean>\r\n            <stddev>0.0017</stddev>\r\n          </noise>\r\n        </z>\r\n      </angular_velocity>\r\n      <linear_acceleration>\r\n        <x>\r\n          <noise type="gaussian">\r\n            <mean>0.0</mean>\r\n            <stddev>1.7e-2</stddev>\r\n          </noise>\r\n        </x>\r\n        <y>\r\n          <noise type="gaussian">\r\n            <mean>0.0</mean>\r\n            <stddev>1.7e-2</stddev>\r\n          </noise>\r\n        </y>\r\n        <z>\r\n          <noise type="gaussian">\r\n            <mean>0.0</mean>\r\n            <stddev>1.7e-2</stddev>\r\n          </noise>\r\n        </z>\r\n      </linear_acceleration>\r\n    </imu>\r\n    <plugin name="imu_controller" filename="libgazebo_ros_imu.so">\r\n      <frame_name>imu_link</frame_name>\r\n      <topic_name>imu/data</topic_name>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"forcetorque-sensors",children:"Force/Torque Sensors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="ft_sensor_link">\r\n  <sensor name="ft_sensor" type="force_torque">\r\n    <always_on>true</always_on>\r\n    <update_rate>100</update_rate>\r\n    <force_torque>\r\n      <frame>sensor</frame>\r\n      <measure_direction>child_to_parent</measure_direction>\r\n    </force_torque>\r\n    <plugin name="ft_sensor_plugin" filename="libgazebo_ros_ft_sensor.so">\r\n      <frame_name>ft_sensor_link</frame_name>\r\n      <topic_name>wrench</topic_name>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"sensor-noise-and-realism",children:"Sensor Noise and Realism"}),"\n",(0,s.jsx)(n.h3,{id:"adding-noise-to-sensors",children:"Adding Noise to Sensors"}),"\n",(0,s.jsx)(n.p,{children:"Real sensors have inherent noise that should be simulated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor name="noisy_camera" type="camera">\r\n  <camera>\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.007</stddev>\r\n    </noise>\r\n  </camera>\r\n</sensor>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"common-noise-models",children:"Common Noise Models"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gaussian Noise"}),": Models electronic noise in sensors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bias"}),": Systematic offset in measurements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Drift"}),": Slowly changing bias over time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Quantization"}),": Discrete measurement steps"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-performance-optimization",children:"Physics Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"collision-simplification",children:"Collision Simplification"}),"\n",(0,s.jsx)(n.p,{children:"Use simpler collision meshes than visual meshes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="complex_visual_simple_collision">\r\n  \x3c!-- Detailed visual mesh --\x3e\r\n  <visual>\r\n    <geometry>\r\n      <mesh>\r\n        <uri>model://robot/meshes/detailed_mesh.dae</uri>\r\n      </mesh>\r\n    </geometry>\r\n  </visual>\r\n\r\n  \x3c!-- Simplified collision mesh --\x3e\r\n  <collision>\r\n    <geometry>\r\n      <mesh>\r\n        <uri>model://robot/meshes/simple_collision_mesh.stl</uri>\r\n      </mesh>\r\n    </geometry>\r\n  </collision>\r\n</link>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"contact-reduction",children:"Contact Reduction"}),"\n",(0,s.jsx)(n.p,{children:"Limit the number of contacts for performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="link_with_contacts">\r\n  <collision>\r\n    <surface>\r\n      <contact>\r\n        <ode>\r\n          <max_vel>10.0</max_vel>\r\n          <min_depth>0.005</min_depth>\r\n        </ode>\r\n      </contact>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-physics-concepts",children:"Advanced Physics Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"multi-body-dynamics",children:"Multi-Body Dynamics"}),"\n",(0,s.jsx)(n.p,{children:"For complex systems with multiple interacting bodies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<world name="multi_body_example">\r\n  <physics type="ode">\r\n    <ode>\r\n      <solver>\r\n        <type>quick</type>\r\n        <iters>50</iters>  \x3c!-- More iterations for complex systems --\x3e\r\n        <sor>1.2</sor>\r\n      </solver>\r\n    </ode>\r\n  </physics>\r\n</world>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"soft-body-simulation",children:"Soft Body Simulation"}),"\n",(0,s.jsx)(n.p,{children:"For deformable objects (requires specialized physics engines):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="soft_body">\r\n  <collision>\r\n    <surface>\r\n      <bounce>\r\n        <restitution_coefficient>0.3</restitution_coefficient>\r\n        <threshold>10000</threshold>\r\n      </bounce>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"sensor-fusion-simulation",children:"Sensor Fusion Simulation"}),"\n",(0,s.jsx)(n.p,{children:"Combining multiple sensors to simulate higher-level perception:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Simulate a perception system that combines camera and LIDAR --\x3e\r\n<gazebo>\r\n  <plugin name="perception_fusion" filename="libgazebo_ros_perception.so">\r\n    <camera_topic>/my_robot/camera/image_raw</camera_topic>\r\n    <lidar_topic>/my_robot/lidar/scan</lidar_topic>\r\n    <output_topic>/my_robot/perception/objects</output_topic>\r\n    <detection_range>10.0</detection_range>\r\n    <fov>1.0472</fov> \x3c!-- 60 degrees --\x3e\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,s.jsx)(n.h3,{id:"physics-instability",children:"Physics Instability"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- If objects vibrate or explode, try these adjustments --\x3e\r\n<physics type="ode">\r\n  <ode>\r\n    <solver>\r\n      <iters>50</iters>        \x3c!-- Increase solver iterations --\x3e\r\n      <sor>1.0</sor>           \x3c!-- Reduce SOR value --\x3e\r\n    </solver>\r\n    <constraints>\r\n      <cfm>1e-5</cfm>          \x3c!-- Small CFM value --\x3e\r\n      <erp>0.8</erp>           \x3c!-- Higher ERP for better constraint --\x3e\r\n    </constraints>\r\n  </ode>\r\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"sensor-data-issues",children:"Sensor Data Issues"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Check coordinate frames"}),": Ensure sensor frames align with expectations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verify update rates"}),": Make sure they match real hardware capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validate noise parameters"}),": Keep them realistic for your application"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,s.jsx)(n.h3,{id:"physics-validation",children:"Physics Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Test physics with simple scenarios\r\n# 1. Drop objects and verify gravity behavior\r\n# 2. Test collisions with known coefficients\r\n# 3. Validate joint limits and dynamics\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sensor-validation",children:"Sensor Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Monitor sensor topics to verify data quality\r\nros2 topic echo /my_robot/camera/image_raw\r\nros2 topic echo /my_robot/lidar/scan\r\nros2 topic echo /my_robot/imu/data\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Start Simple"}),": Begin with basic physics and gradually add complexity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validate Against Reality"}),": Compare simulation results with real-world tests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Balance Accuracy and Performance"}),": Optimize for your specific use case"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document Assumptions"}),": Keep track of modeling simplifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Appropriate Timesteps"}),": Match physics timestep to your control frequency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test Edge Cases"}),": Verify behavior under extreme conditions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Physics and sensor simulation form the foundation of realistic robot simulation. Properly configured physics parameters ensure stable and accurate simulation, while realistic sensor models provide the data needed to develop and test perception and control algorithms. Understanding these concepts is essential for creating simulations that effectively bridge the gap between virtual and real-world robotics development."}),"\n",(0,s.jsx)(n.p,{children:"In the next section, we'll explore using Unity for advanced robot visualization and simulation."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(6540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);