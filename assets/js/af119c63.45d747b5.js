"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[2085],{1790:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>t,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"module3/manipulation-grasping","title":"Manipulation and Grasping","description":"Introduction to Robotic Manipulation","source":"@site/docs/module3/manipulation-grasping.md","sourceDirName":"module3","slug":"/module3/manipulation-grasping","permalink":"/Physical-AI-Humanoid-book/docs/module3/manipulation-grasping","draft":false,"unlisted":false,"editUrl":"https://github.com/user/physical-ai-humanoid-robotics/tree/main/docs/module3/manipulation-grasping.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Practical Lab: Building an AI-Powered Robot","permalink":"/Physical-AI-Humanoid-book/docs/module3/lab-ai-robot"},"next":{"title":"Reinforcement Learning for Control","permalink":"/Physical-AI-Humanoid-book/docs/module3/reinforcement-learning"}}');var i=r(4848),s=r(8453);const t={},o="Manipulation and Grasping",l={},p=[{value:"Introduction to Robotic Manipulation",id:"introduction-to-robotic-manipulation",level:2},{value:"Manipulation System Architecture",id:"manipulation-system-architecture",level:2},{value:"Grasp Planning Fundamentals",id:"grasp-planning-fundamentals",level:2},{value:"Grasp Representation",id:"grasp-representation",level:3},{value:"Grasp Quality Metrics",id:"grasp-quality-metrics",level:3},{value:"Isaac Manipulation Components",id:"isaac-manipulation-components",level:2},{value:"Isaac Manipulation Stack",id:"isaac-manipulation-stack",level:3},{value:"Grasp Detection Networks",id:"grasp-detection-networks",level:3},{value:"Motion Planning for Manipulation",id:"motion-planning-for-manipulation",level:2},{value:"Cartesian Motion Planning",id:"cartesian-motion-planning",level:3},{value:"Trajectory Optimization",id:"trajectory-optimization",level:3},{value:"Force Control and Compliance",id:"force-control-and-compliance",level:2},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Force/Torque Sensing Integration",id:"forcetorque-sensing-integration",level:3},{value:"Grasp Synthesis and Learning",id:"grasp-synthesis-and-learning",level:2},{value:"Learning-based Grasp Planning",id:"learning-based-grasp-planning",level:3},{value:"Grasp Failure Recovery",id:"grasp-failure-recovery",level:3},{value:"Multi-Fingered Hand Manipulation",id:"multi-fingered-hand-manipulation",level:2},{value:"Dexterous Manipulation",id:"dexterous-manipulation",level:3},{value:"Simulation and Real-World Transfer",id:"simulation-and-real-world-transfer",level:2},{value:"Sim-to-Real Considerations",id:"sim-to-real-considerations",level:3},{value:"Best Practices for Manipulation Systems",id:"best-practices-for-manipulation-systems",level:2},{value:"1. Safety Considerations",id:"1-safety-considerations",level:3},{value:"2. Robustness",id:"2-robustness",level:3},{value:"3. Efficiency",id:"3-efficiency",level:3},{value:"4. Calibration",id:"4-calibration",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Grasp Failures",id:"1-grasp-failures",level:3},{value:"2. Collision Issues",id:"2-collision-issues",level:3},{value:"3. Force Control Problems",id:"3-force-control-problems",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"manipulation-and-grasping",children:"Manipulation and Grasping"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-robotic-manipulation",children:"Introduction to Robotic Manipulation"}),"\n",(0,i.jsx)(n.p,{children:"Robotic manipulation involves the precise control of robot arms and end-effectors to interact with objects in the environment. This encompasses a wide range of tasks including picking, placing, assembly, and tool use. Grasping, a fundamental aspect of manipulation, requires the robot to securely hold objects using its end-effector (typically a gripper or robotic hand)."}),"\n",(0,i.jsx)(n.h2,{id:"manipulation-system-architecture",children:"Manipulation System Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The manipulation system typically consists of several interconnected components:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Perception \u2192 Grasp Planning \u2192 Motion Planning \u2192 Control \u2192 Execution\r\n     \u2193            \u2193              \u2193            \u2193        \u2193\r\nObject       Grasp Pose    Joint Trajectory  Torque  Robot\r\nDetection    Generation    Generation       Commands  Arm\n"})}),"\n",(0,i.jsx)(n.h2,{id:"grasp-planning-fundamentals",children:"Grasp Planning Fundamentals"}),"\n",(0,i.jsx)(n.h3,{id:"grasp-representation",children:"Grasp Representation"}),"\n",(0,i.jsx)(n.p,{children:"Grasps are typically represented using a 6D pose (position and orientation) along with grasp parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct GraspPose {\r\n    // 6D pose of the gripper relative to the object\r\n    Vector3 position;      // x, y, z position\r\n    Quaternion orientation; // rotation quaternion\r\n    float width;           // gripper width\r\n    float approach_angle;  // approach angle\r\n    float grasp_quality;   // quality metric\r\n};\r\n\r\nclass GraspPlanner {\r\npublic:\r\n    // Generate grasp candidates for an object\r\n    std::vector<GraspPose> generateGrasps(const Object& object) {\r\n        std::vector<GraspPose> candidates;\r\n\r\n        // Generate top-down grasps\r\n        auto top_down_grasps = generateTopDownGrasps(object);\r\n        candidates.insert(candidates.end(),\r\n                         top_down_grasps.begin(), top_down_grasps.end());\r\n\r\n        // Generate side grasps\r\n        auto side_grasps = generateSideGrasps(object);\r\n        candidates.insert(candidates.end(),\r\n                         side_grasps.begin(), side_grasps.end());\r\n\r\n        // Filter and rank grasps\r\n        auto filtered_grasps = filterGrasps(candidates, object);\r\n        return rankGrasps(filtered_grasps, object);\r\n    }\r\n\r\nprivate:\r\n    std::vector<GraspPose> generateTopDownGrasps(const Object& object) {\r\n        std::vector<GraspPose> grasps;\r\n\r\n        // Calculate top-down grasp positions\r\n        Vector3 top_center = object.boundingBox.center;\r\n        top_center.z = object.boundingBox.max.z; // Position above object\r\n\r\n        // Generate multiple approach angles\r\n        for (float angle = 0; angle < 2 * M_PI; angle += M_PI/4) {\r\n            GraspPose grasp;\r\n            grasp.position = top_center;\r\n            grasp.orientation = createTopDownOrientation(angle);\r\n            grasp.width = calculateGripperWidth(object);\r\n            grasp.approach_angle = angle;\r\n            grasp.grasp_quality = evaluateGraspQuality(grasp, object);\r\n\r\n            grasps.push_back(grasp);\r\n        }\r\n\r\n        return grasps;\r\n    }\r\n\r\n    std::vector<GraspPose> generateSideGrasps(const Object& object) {\r\n        // Similar implementation for side grasps\r\n        std::vector<GraspPose> grasps;\r\n\r\n        // Generate grasps from different sides\r\n        for (int side = 0; side < 4; side++) {\r\n            Vector3 side_position = calculateSidePosition(object, side);\r\n            Quaternion side_orientation = calculateSideOrientation(side);\r\n\r\n            GraspPose grasp;\r\n            grasp.position = side_position;\r\n            grasp.orientation = side_orientation;\r\n            grasp.width = calculateGripperWidth(object);\r\n            grasp.approach_angle = side * M_PI/2;\r\n            grasp.grasp_quality = evaluateGraspQuality(grasp, object);\r\n\r\n            grasps.push_back(grasp);\r\n        }\r\n\r\n        return grasps;\r\n    }\r\n\r\n    float evaluateGraspQuality(const GraspPose& grasp, const Object& object) {\r\n        // Evaluate grasp quality based on multiple factors\r\n        float stability_score = calculateStabilityScore(grasp, object);\r\n        float force_closure_score = calculateForceClosureScore(grasp, object);\r\n        float accessibility_score = calculateAccessibilityScore(grasp, object);\r\n\r\n        // Weighted combination of scores\r\n        return 0.4 * stability_score + 0.4 * force_closure_score + 0.2 * accessibility_score;\r\n    }\r\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"grasp-quality-metrics",children:"Grasp Quality Metrics"}),"\n",(0,i.jsx)(n.p,{children:"Different metrics are used to evaluate grasp quality:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class GraspQualityEvaluator {\r\npublic:\r\n    // Force closure analysis\r\n    float calculateForceClosureScore(const GraspPose& grasp, const Object& object) {\r\n        // Calculate if the grasp can resist external forces\r\n        // using force closure analysis\r\n\r\n        // Simplified implementation\r\n        float friction_coeff = 0.8; // Typical friction coefficient\r\n        float contact_area = calculateContactArea(grasp, object);\r\n\r\n        // Force closure depends on friction and contact geometry\r\n        float force_closure = friction_coeff * contact_area * 10.0; // Scale factor\r\n\r\n        // Normalize to [0, 1]\r\n        return std::min(1.0f, force_closure);\r\n    }\r\n\r\n    // Stability analysis\r\n    float calculateStabilityScore(const GraspPose& grasp, const Object& object) {\r\n        // Evaluate grasp stability considering object properties\r\n        float object_weight = object.mass * 9.81; // Weight in Newtons\r\n        float grasp_width = grasp.width;\r\n        float object_size = calculateObjectSize(object);\r\n\r\n        // Stability depends on grasp width relative to object size\r\n        float stability_ratio = grasp_width / object_size;\r\n\r\n        // Optimal grasp width is typically 60-80% of object size\r\n        float optimal_ratio = 0.7;\r\n        float stability_score = 1.0 - std::abs(stability_ratio - optimal_ratio) / optimal_ratio;\r\n\r\n        return std::max(0.0f, std::min(1.0f, stability_score));\r\n    }\r\n\r\n    // Accessibility analysis\r\n    float calculateAccessibilityScore(const GraspPose& grasp, const Scene& scene) {\r\n        // Check if the grasp pose is accessible given robot kinematics\r\n        // and environmental constraints\r\n\r\n        // Check for collisions in approach path\r\n        float collision_free_score = checkApproachPath(grasp, scene);\r\n\r\n        // Check if pose is within robot workspace\r\n        float workspace_score = checkWorkspaceConstraints(grasp);\r\n\r\n        return (collision_free_score + workspace_score) / 2.0;\r\n    }\r\n\r\nprivate:\r\n    float calculateContactArea(const GraspPose& grasp, const Object& object) {\r\n        // Calculate contact area between gripper and object\r\n        // This is a simplified estimation\r\n        return grasp.width * 0.02; // Assume 2cm contact depth\r\n    }\r\n\r\n    float calculateObjectSize(const Object& object) {\r\n        // Calculate characteristic size of object\r\n        auto bbox = object.boundingBox;\r\n        Vector3 size = bbox.max - bbox.min;\r\n        return std::max({size.x, size.y, size.z});\r\n    }\r\n\r\n    float checkApproachPath(const GraspPose& grasp, const Scene& scene) {\r\n        // Check for collisions along approach path\r\n        // Implementation would use collision checking algorithms\r\n        return 1.0; // Simplified - assume collision-free for now\r\n    }\r\n\r\n    float checkWorkspaceConstraints(const GraspPose& grasp) {\r\n        // Check if grasp pose is within robot workspace\r\n        // Implementation would use robot kinematics\r\n        return 1.0; // Simplified - assume within workspace\r\n    }\r\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"isaac-manipulation-components",children:"Isaac Manipulation Components"}),"\n",(0,i.jsx)(n.h3,{id:"isaac-manipulation-stack",children:"Isaac Manipulation Stack"}),"\n",(0,i.jsx)(n.p,{children:"The Isaac Platform provides a comprehensive manipulation stack:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Example Isaac manipulation stack usage\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.franka import Franka\r\nfrom omni.isaac.core.objects import DynamicCuboid\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nimport numpy as np\r\n\r\nclass IsaacManipulationSystem:\r\n    def __init__(self):\r\n        # Initialize Isaac world\r\n        self.world = World(stage_units_in_meters=1.0)\r\n        self.world.scene.add_default_ground_plane()\r\n\r\n        # Add robot\r\n        self.robot = self.world.scene.add(\r\n            Franka(\r\n                prim_path="/World/Franka",\r\n                name="franka",\r\n                position=np.array([0, 0, 0]),\r\n                orientation=np.array([0, 0, 0, 1])\r\n            )\r\n        )\r\n\r\n        # Initialize manipulation components\r\n        self.grasp_planner = self.initialize_grasp_planner()\r\n        self.motion_planner = self.initialize_motion_planner()\r\n        self.controller = self.initialize_controller()\r\n\r\n    def initialize_grasp_planner(self):\r\n        """Initialize Isaac\'s grasp planning component"""\r\n        # In real implementation, this would initialize Isaac\'s grasp planner\r\n        return GraspPlanner()\r\n\r\n    def initialize_motion_planner(self):\r\n        """Initialize motion planning component"""\r\n        # In real implementation, this would initialize Isaac\'s motion planner\r\n        return MotionPlanner()\r\n\r\n    def initialize_controller(self):\r\n        """Initialize robot controller"""\r\n        return RobotController(self.robot)\r\n\r\n    def pick_and_place(self, target_object, place_position):\r\n        """Execute pick and place operation"""\r\n        # 1. Move to pre-grasp position\r\n        pre_grasp_pos = self.calculate_pre_grasp_position(target_object)\r\n        self.move_to_position(pre_grasp_pos)\r\n\r\n        # 2. Plan and execute grasp\r\n        grasp_pose = self.plan_grasp(target_object)\r\n        self.execute_grasp(grasp_pose)\r\n\r\n        # 3. Lift object\r\n        self.lift_object()\r\n\r\n        # 4. Move to place position\r\n        self.move_to_position(place_position)\r\n\r\n        # 5. Release object\r\n        self.release_object()\r\n\r\n        # 6. Retract\r\n        self.retract()\r\n\r\n    def plan_grasp(self, target_object):\r\n        """Plan optimal grasp for target object"""\r\n        # Use Isaac\'s perception system to get object information\r\n        object_info = self.get_object_info(target_object)\r\n\r\n        # Generate grasp candidates\r\n        grasp_candidates = self.grasp_planner.generateGrasps(object_info)\r\n\r\n        # Select best grasp\r\n        best_grasp = self.select_best_grasp(grasp_candidates)\r\n\r\n        return best_grasp\r\n\r\n    def execute_grasp(self, grasp_pose):\r\n        """Execute the planned grasp"""\r\n        # Move to grasp approach position\r\n        approach_pos = self.calculate_approach_position(grasp_pose)\r\n        self.move_to_position(approach_pos)\r\n\r\n        # Align gripper to grasp pose\r\n        self.align_to_grasp(grasp_pose)\r\n\r\n        # Execute grasp motion\r\n        self.close_gripper()\r\n\r\n        # Verify grasp success\r\n        if self.verify_grasp():\r\n            print("Grasp successful!")\r\n        else:\r\n            print("Grasp failed!")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"grasp-detection-networks",children:"Grasp Detection Networks"}),"\n",(0,i.jsx)(n.p,{children:"Isaac provides pre-trained grasp detection networks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class GraspDetectionNetwork:\r\n    def __init__(self):\r\n        # Load pre-trained grasp detection model\r\n        self.model = self.load_grasp_detection_model()\r\n\r\n    def detect_grasps(self, rgb_image, depth_image):\r\n        """Detect grasp candidates from RGB-D input"""\r\n        # Preprocess images\r\n        processed_rgb = self.preprocess_rgb(rgb_image)\r\n        processed_depth = self.preprocess_depth(depth_image)\r\n\r\n        # Combine RGB and depth\r\n        rgbd_input = np.concatenate([processed_rgb, processed_depth], axis=-1)\r\n\r\n        # Run inference\r\n        grasp_heatmap, grasp_angles = self.model.infer(rgbd_input)\r\n\r\n        # Extract grasp candidates from heatmap\r\n        grasp_candidates = self.extract_grasp_candidates(\r\n            grasp_heatmap, grasp_angles\r\n        )\r\n\r\n        # Filter and rank grasps\r\n        ranked_grasps = self.rank_grasps(grasp_candidates)\r\n\r\n        return ranked_grasps\r\n\r\n    def extract_grasp_candidates(self, heatmap, angles):\r\n        """Extract grasp candidates from network outputs"""\r\n        import cv2\r\n\r\n        # Find local maxima in heatmap\r\n        local_maxima = self.find_local_maxima(heatmap)\r\n\r\n        grasps = []\r\n        for point in local_maxima:\r\n            x, y = point\r\n            angle = angles[y, x]\r\n            quality = heatmap[y, x]\r\n\r\n            # Convert to world coordinates\r\n            world_pos = self.pixel_to_world(x, y, depth_image[y, x])\r\n\r\n            grasp = {\r\n                \'position\': world_pos,\r\n                \'angle\': angle,\r\n                \'quality\': quality,\r\n                \'width\': self.estimate_gripper_width(world_pos)\r\n            }\r\n\r\n            grasps.append(grasp)\r\n\r\n        return grasps\r\n\r\n    def find_local_maxima(self, heatmap, threshold=0.5):\r\n        """Find local maxima in grasp heatmap"""\r\n        import cv2\r\n\r\n        # Apply threshold\r\n        _, thresholded = cv2.threshold(heatmap, threshold, 1.0, cv2.THRESH_BINARY)\r\n\r\n        # Find connected components\r\n        num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(\r\n            (thresholded * 255).astype(np.uint8)\r\n        )\r\n\r\n        # Find maxima within each component\r\n        maxima = []\r\n        for i in range(1, num_labels):  # Skip background\r\n            mask = (labels == i)\r\n            y_coords, x_coords = np.where(mask)\r\n            max_idx = np.argmax(heatmap[mask])\r\n            max_x = x_coords[max_idx]\r\n            max_y = y_coords[max_idx]\r\n            maxima.append((max_x, max_y))\r\n\r\n        return maxima\n'})}),"\n",(0,i.jsx)(n.h2,{id:"motion-planning-for-manipulation",children:"Motion Planning for Manipulation"}),"\n",(0,i.jsx)(n.h3,{id:"cartesian-motion-planning",children:"Cartesian Motion Planning"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class CartesianMotionPlanner:\r\n    def __init__(self, robot):\r\n        self.robot = robot\r\n        self.kinematics = self.initialize_kinematics(robot)\r\n        self.collision_checker = self.initialize_collision_checker()\r\n\r\n    def plan_cartesian_motion(self, start_pose, end_pose, obstacles=None):\r\n        """Plan Cartesian motion between two poses"""\r\n        # Generate waypoints between start and end poses\r\n        waypoints = self.interpolate_poses(start_pose, end_pose)\r\n\r\n        # Check each waypoint for collisions\r\n        collision_free_waypoints = []\r\n        for waypoint in waypoints:\r\n            if not self.collision_checker.check_collision(waypoint, obstacles):\r\n                collision_free_waypoints.append(waypoint)\r\n            else:\r\n                # Try to find alternative path\r\n                alternative_path = self.find_alternative_path(waypoint, obstacles)\r\n                if alternative_path:\r\n                    collision_free_waypoints.extend(alternative_path)\r\n                else:\r\n                    raise Exception("No collision-free path found")\r\n\r\n        # Convert Cartesian waypoints to joint space\r\n        joint_trajectories = []\r\n        for waypoint in collision_free_waypoints:\r\n            joint_config = self.inverse_kinematics(waypoint)\r\n            if joint_config:\r\n                joint_trajectories.append(joint_config)\r\n            else:\r\n                raise Exception("IK solution not found for waypoint")\r\n\r\n        return joint_trajectories\r\n\r\n    def interpolate_poses(self, start_pose, end_pose, num_waypoints=20):\r\n        """Interpolate between two poses"""\r\n        waypoints = []\r\n\r\n        for i in range(num_waypoints + 1):\r\n            t = i / num_waypoints\r\n\r\n            # Linear interpolation for position\r\n            pos = start_pose.position + t * (end_pose.position - start_pose.position)\r\n\r\n            # Spherical linear interpolation for orientation\r\n            quat = self.slerp(start_pose.orientation, end_pose.orientation, t)\r\n\r\n            waypoint = Pose(position=pos, orientation=quat)\r\n            waypoints.append(waypoint)\r\n\r\n        return waypoints\r\n\r\n    def slerp(self, q1, q2, t):\r\n        """Spherical linear interpolation between quaternions"""\r\n        # Calculate dot product\r\n        dot = q1.w*q2.w + q1.x*q2.x + q1.y*q2.y + q1.z*q2.z\r\n\r\n        # If dot product is negative, negate one quaternion\r\n        if dot < 0.0:\r\n            q2 = Quaternion(-q2.w, -q2.x, -q2.y, -q2.z)\r\n            dot = -dot\r\n\r\n        # Calculate interpolation factors\r\n        if dot > 0.9995:\r\n            # Linear interpolation for very similar quaternions\r\n            result = Quaternion(\r\n                q1.w + t*(q2.w - q1.w),\r\n                q1.x + t*(q2.x - q1.x),\r\n                q1.y + t*(q2.y - q1.y),\r\n                q1.z + t*(q2.z - q1.z)\r\n            )\r\n        else:\r\n            # Spherical interpolation\r\n            theta_0 = np.arccos(dot)\r\n            sin_theta_0 = np.sin(theta_0)\r\n            theta = theta_0 * t\r\n            sin_theta = np.sin(theta)\r\n\r\n            s0 = np.cos(theta) - dot * sin_theta / sin_theta_0\r\n            s1 = sin_theta / sin_theta_0\r\n\r\n            result = Quaternion(\r\n                s0*q1.w + s1*q2.w,\r\n                s0*q1.x + s1*q2.x,\r\n                s0*q1.y + s1*q2.y,\r\n                s0*q1.z + s1*q2.z\r\n            )\r\n\r\n        # Normalize the result\r\n        norm = np.sqrt(result.w**2 + result.x**2 + result.y**2 + result.z**2)\r\n        return Quaternion(\r\n            result.w/norm, result.x/norm, result.y/norm, result.z/norm\r\n        )\n'})}),"\n",(0,i.jsx)(n.h3,{id:"trajectory-optimization",children:"Trajectory Optimization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class TrajectoryOptimizer:\r\n    def __init__(self):\r\n        self.optimizer = self.setup_optimizer()\r\n\r\n    def optimize_trajectory(self, joint_trajectory, constraints=None):\r\n        """Optimize joint trajectory for smoothness and efficiency"""\r\n        # Convert to numpy array for optimization\r\n        trajectory_array = np.array(joint_trajectory)\r\n\r\n        # Apply trajectory smoothing\r\n        smoothed_trajectory = self.smooth_trajectory(trajectory_array)\r\n\r\n        # Optimize for minimum jerk\r\n        jerk_optimized = self.minimize_jerk(smoothed_trajectory)\r\n\r\n        # Apply constraints\r\n        if constraints:\r\n            constrained_trajectory = self.apply_constraints(jerk_optimized, constraints)\r\n        else:\r\n            constrained_trajectory = jerk_optimized\r\n\r\n        return constrained_trajectory.tolist()\r\n\r\n    def smooth_trajectory(self, trajectory):\r\n        """Apply smoothing to trajectory"""\r\n        import scipy.ndimage as ndimage\r\n\r\n        # Apply Gaussian smoothing to each joint dimension\r\n        smoothed = np.zeros_like(trajectory)\r\n        for i in range(trajectory.shape[1]):  # For each joint\r\n            smoothed[:, i] = ndimage.gaussian_filter1d(trajectory[:, i], sigma=1.0)\r\n\r\n        return smoothed\r\n\r\n    def minimize_jerk(self, trajectory):\r\n        """Minimize jerk in trajectory"""\r\n        # Calculate jerk (third derivative) and minimize it\r\n        velocities = np.gradient(trajectory, axis=0)\r\n        accelerations = np.gradient(velocities, axis=0)\r\n        jerks = np.gradient(accelerations, axis=0)\r\n\r\n        # Minimize jerk by adjusting trajectory points\r\n        optimized = trajectory.copy()\r\n        for i in range(1, len(trajectory) - 1):\r\n            # Adjust middle points to reduce jerk\r\n            jerk_reduction = -0.01 * jerks[i]  # Small adjustment factor\r\n            optimized[i] += jerk_reduction\r\n\r\n        return optimized\n'})}),"\n",(0,i.jsx)(n.h2,{id:"force-control-and-compliance",children:"Force Control and Compliance"}),"\n",(0,i.jsx)(n.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ImpedanceController:\r\n    def __init__(self, robot, stiffness=1000, damping=20):\r\n        self.robot = robot\r\n        self.stiffness = stiffness  # N/m\r\n        self.damping = damping      # Ns/m\r\n        self.mass = 1.0            # kg (effective mass)\r\n\r\n    def apply_impedance_control(self, desired_pose, actual_pose, external_force):\r\n        """Apply impedance control to achieve desired compliance"""\r\n        # Calculate position and velocity errors\r\n        pos_error = desired_pose.position - actual_pose.position\r\n        vel_error = self.calculate_velocity_error()\r\n\r\n        # Calculate impedance force\r\n        impedance_force = (\r\n            self.stiffness * pos_error +\r\n            self.damping * vel_error +\r\n            self.mass * self.calculate_acceleration_error()\r\n        )\r\n\r\n        # Add external force compensation\r\n        total_force = impedance_force + external_force\r\n\r\n        # Apply force control\r\n        self.apply_force(total_force)\r\n\r\n        return total_force\r\n\r\n    def adjust_compliance(self, task_type):\r\n        """Adjust compliance based on task requirements"""\r\n        if task_type == "delicate":\r\n            self.stiffness = 100   # Low stiffness for delicate objects\r\n            self.damping = 5       # Low damping\r\n        elif task_type == "stiff":\r\n            self.stiffness = 5000  # High stiffness for precise positioning\r\n            self.damping = 50      # High damping\r\n        elif task_type == "assembly":\r\n            self.stiffness = 1000  # Medium stiffness for assembly tasks\r\n            self.damping = 20      # Medium damping\n'})}),"\n",(0,i.jsx)(n.h3,{id:"forcetorque-sensing-integration",children:"Force/Torque Sensing Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ForceTorqueController:\r\n    def __init__(self, robot, sensor):\r\n        self.robot = robot\r\n        self.sensor = sensor\r\n        self.desired_force = np.zeros(6)  # Fx, Fy, Fz, Tx, Ty, Tz\r\n        self.force_threshold = 50.0      # N\r\n        self.torque_threshold = 5.0      # Nm\r\n\r\n    def execute_force_controlled_motion(self, motion_profile):\r\n        """Execute motion with force feedback control"""\r\n        for waypoint in motion_profile:\r\n            # Get current force/torque readings\r\n            current_force = self.sensor.get_force_torque()\r\n\r\n            # Check for excessive forces\r\n            if self.is_excessive_force(current_force):\r\n                print("Excessive force detected, stopping motion")\r\n                self.emergency_stop()\r\n                return False\r\n\r\n            # Adjust motion based on force feedback\r\n            adjusted_waypoint = self.adjust_waypoint_with_force(\r\n                waypoint, current_force\r\n            )\r\n\r\n            # Move to adjusted waypoint\r\n            self.robot.move_to_joint_position(adjusted_waypoint)\r\n\r\n        return True\r\n\r\n    def is_excessive_force(self, force_torque):\r\n        """Check if forces/torques exceed safety limits"""\r\n        force_magnitude = np.linalg.norm(force_torque[:3])\r\n        torque_magnitude = np.linalg.norm(force_torque[3:])\r\n\r\n        return (force_magnitude > self.force_threshold or\r\n                torque_magnitude > self.torque_threshold)\r\n\r\n    def adjust_waypoint_with_force(self, waypoint, current_force):\r\n        """Adjust waypoint based on current force readings"""\r\n        # Calculate force deviation from desired\r\n        force_error = current_force - self.desired_force\r\n\r\n        # Apply compliance adjustment\r\n        compliance_adjustment = 0.001 * force_error  # Small adjustment factor\r\n\r\n        # Adjust waypoint position\r\n        adjusted_waypoint = waypoint.copy()\r\n        adjusted_waypoint[:3] += compliance_adjustment[:3]  # Position adjustment\r\n\r\n        return adjusted_waypoint\n'})}),"\n",(0,i.jsx)(n.h2,{id:"grasp-synthesis-and-learning",children:"Grasp Synthesis and Learning"}),"\n",(0,i.jsx)(n.h3,{id:"learning-based-grasp-planning",children:"Learning-based Grasp Planning"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class LearningBasedGraspPlanner:\r\n    def __init__(self):\r\n        self.grasp_network = self.load_grasp_network()\r\n        self.dataset_stats = self.load_dataset_statistics()\r\n\r\n    def plan_grasp_with_learning(self, object_pointcloud):\r\n        """Plan grasp using learned approach"""\r\n        # Preprocess point cloud\r\n        processed_cloud = self.preprocess_pointcloud(object_pointcloud)\r\n\r\n        # Run grasp network inference\r\n        grasp_probabilities = self.grasp_network.infer(processed_cloud)\r\n\r\n        # Generate grasp candidates from probabilities\r\n        grasp_candidates = self.generate_grasps_from_probabilities(\r\n            grasp_probabilities, object_pointcloud\r\n        )\r\n\r\n        # Rank grasps using learned quality function\r\n        ranked_grasps = self.rank_grasps_with_learning(grasp_candidates)\r\n\r\n        return ranked_grasps\r\n\r\n    def generate_grasps_from_probabilities(self, probabilities, pointcloud):\r\n        """Generate grasp candidates from probability map"""\r\n        grasps = []\r\n\r\n        # Find high-probability regions\r\n        high_prob_indices = np.where(probabilities > 0.5)[0]\r\n\r\n        for idx in high_prob_indices:\r\n            point = pointcloud[idx]\r\n\r\n            # Generate multiple grasp orientations at this point\r\n            for angle in np.linspace(0, 2*np.pi, 8):\r\n                grasp = self.create_grasp_at_point(point, angle)\r\n                grasp[\'quality\'] = probabilities[idx]\r\n                grasps.append(grasp)\r\n\r\n        return grasps\r\n\r\n    def rank_grasps_with_learning(self, grasps):\r\n        """Rank grasps using learned quality assessment"""\r\n        # Use learned quality function to rank grasps\r\n        ranked_grasps = sorted(grasps, key=lambda g: g[\'quality\'], reverse=True)\r\n        return ranked_grasps\n'})}),"\n",(0,i.jsx)(n.h3,{id:"grasp-failure-recovery",children:"Grasp Failure Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class GraspFailureRecovery:\r\n    def __init__(self, manipulation_system):\r\n        self.manip_system = manipulation_system\r\n        self.failure_history = []\r\n\r\n    def handle_grasp_failure(self, failed_grasp, object_info):\r\n        """Handle grasp failure and attempt recovery"""\r\n        # Log failure for learning\r\n        self.log_failure(failed_grasp, object_info)\r\n\r\n        # Analyze failure type\r\n        failure_type = self.analyze_failure_type(failed_grasp, object_info)\r\n\r\n        # Apply appropriate recovery strategy\r\n        if failure_type == "slip":\r\n            return self.recover_from_slip(failed_grasp, object_info)\r\n        elif failure_type == "miss":\r\n            return self.recover_from_miss(failed_grasp, object_info)\r\n        elif failure_type == "collision":\r\n            return self.recover_from_collision(failed_grasp, object_info)\r\n        else:\r\n            return self.general_recovery(failed_grasp, object_info)\r\n\r\n    def recover_from_slip(self, failed_grasp, object_info):\r\n        """Recover from grasp slip failure"""\r\n        # Try a different grasp with higher grip force\r\n        new_grasp = failed_grasp.copy()\r\n        new_grasp[\'grip_force\'] = min(100, new_grasp[\'grip_force\'] * 1.5)  # Increase grip force\r\n\r\n        # Verify the new grasp is still valid\r\n        if self.verify_grasp_feasibility(new_grasp, object_info):\r\n            return self.execute_grasp(new_grasp)\r\n        else:\r\n            # Try a different grasp pose\r\n            alternative_grasps = self.generate_alternative_grasps(object_info)\r\n            for alt_grasp in alternative_grasps:\r\n                if self.execute_grasp(alt_grasp):\r\n                    return True\r\n\r\n        return False\r\n\r\n    def recover_from_miss(self, failed_grasp, object_info):\r\n        """Recover from grasp miss failure"""\r\n        # Refine object pose estimate\r\n        refined_pose = self.refine_object_pose(object_info)\r\n\r\n        # Generate new grasp based on refined pose\r\n        new_grasps = self.generate_grasps(refined_pose)\r\n\r\n        # Try the highest quality grasp\r\n        if new_grasps:\r\n            return self.execute_grasp(new_grasps[0])\r\n\r\n        return False\r\n\r\n    def log_failure(self, failed_grasp, object_info):\r\n        """Log failure for future learning"""\r\n        failure_record = {\r\n            \'grasp\': failed_grasp,\r\n            \'object\': object_info,\r\n            \'timestamp\': time.time(),\r\n            \'environment\': self.get_environment_state()\r\n        }\r\n        self.failure_history.append(failure_record)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"multi-fingered-hand-manipulation",children:"Multi-Fingered Hand Manipulation"}),"\n",(0,i.jsx)(n.h3,{id:"dexterous-manipulation",children:"Dexterous Manipulation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class DexterousHandController:\r\n    def __init__(self, hand_type="allegro", num_fingers=4):\r\n        self.hand_type = hand_type\r\n        self.num_fingers = num_fingers\r\n        self.finger_positions = np.zeros(num_fingers * 3)  # 3 joints per finger\r\n        self.finger_forces = np.zeros(num_fingers)\r\n\r\n    def execute_dexterous_grasp(self, object_shape, grasp_type="cylindrical"):\r\n        """Execute dexterous grasp based on object shape"""\r\n        if grasp_type == "cylindrical":\r\n            return self.execute_cylindrical_grasp(object_shape)\r\n        elif grasp_type == "spherical":\r\n            return self.execute_spherical_grasp(object_shape)\r\n        elif grasp_type == "parallel":\r\n            return self.execute_parallel_grasp(object_shape)\r\n        elif grasp_type == "tripod":\r\n            return self.execute_tripod_grasp(object_shape)\r\n        else:\r\n            return self.execute_power_grasp(object_shape)\r\n\r\n    def execute_cylindrical_grasp(self, object_shape):\r\n        """Execute cylindrical grasp for cylindrical objects"""\r\n        # Calculate optimal finger positions for cylindrical grasp\r\n        finger_positions = self.calculate_cylindrical_finger_positions(object_shape)\r\n\r\n        # Apply finger forces for stable grasp\r\n        finger_forces = self.calculate_cylindrical_finger_forces(object_shape)\r\n\r\n        # Execute the grasp\r\n        self.move_fingers_to_positions(finger_positions)\r\n        self.apply_finger_forces(finger_forces)\r\n\r\n        return self.verify_grasp_success()\r\n\r\n    def calculate_cylindrical_finger_positions(self, object_shape):\r\n        """Calculate optimal finger positions for cylindrical grasp"""\r\n        # Calculate grasp diameter\r\n        grasp_diameter = object_shape.diameter * 1.1  # Slightly larger than object\r\n\r\n        # Calculate finger positions around cylinder\r\n        finger_positions = []\r\n        for i in range(self.num_fingers):\r\n            angle = (2 * np.pi * i) / self.num_fingers\r\n            radius = grasp_diameter / 2.0\r\n\r\n            x = radius * np.cos(angle)\r\n            y = radius * np.sin(angle)\r\n            z = 0  # Center height\r\n\r\n            finger_positions.extend([x, y, z])\r\n\r\n        return np.array(finger_positions)\r\n\r\n    def execute_in_hand_manipulation(self, object, target_pose):\r\n        """Execute in-hand manipulation to reposition object"""\r\n        # Calculate manipulation sequence\r\n        manipulation_sequence = self.plan_in_hand_manipulation(\r\n            object.current_pose, target_pose\r\n        )\r\n\r\n        # Execute manipulation steps\r\n        for step in manipulation_sequence:\r\n            self.execute_manipulation_step(step)\r\n\r\n        return self.verify_object_pose(target_pose)\r\n\r\n    def plan_in_hand_manipulation(self, current_pose, target_pose):\r\n        """Plan in-hand manipulation sequence"""\r\n        # Calculate the difference between current and target poses\r\n        pose_diff = self.calculate_pose_difference(current_pose, target_pose)\r\n\r\n        # Generate manipulation steps based on pose difference\r\n        steps = []\r\n\r\n        # If rotation is needed\r\n        if np.linalg.norm(pose_diff.rotation) > 0.1:\r\n            steps.append({\r\n                \'type\': \'rotate\',\r\n                \'angle\': pose_diff.rotation,\r\n                \'pivot\': \'object_center\'\r\n            })\r\n\r\n        # If translation is needed\r\n        if np.linalg.norm(pose_diff.translation) > 0.01:\r\n            steps.append({\r\n                \'type\': \'translate\',\r\n                \'direction\': pose_diff.translation,\r\n                \'distance\': np.linalg.norm(pose_diff.translation)\r\n            })\r\n\r\n        return steps\n'})}),"\n",(0,i.jsx)(n.h2,{id:"simulation-and-real-world-transfer",children:"Simulation and Real-World Transfer"}),"\n",(0,i.jsx)(n.h3,{id:"sim-to-real-considerations",children:"Sim-to-Real Considerations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class SimToRealManipulation:\r\n    def __init__(self):\r\n        self.sim_parameters = self.load_sim_parameters()\r\n        self.real_parameters = self.load_real_parameters()\r\n\r\n    def adapt_grasp_for_real_world(self, sim_grasp):\r\n        """Adapt grasp from simulation to real world"""\r\n        # Apply domain randomization corrections\r\n        real_grasp = sim_grasp.copy()\r\n\r\n        # Adjust for real-world uncertainties\r\n        real_grasp.position += self.add_sensor_noise(real_grasp.position)\r\n        real_grasp.orientation = self.add_orientation_uncertainty(real_grasp.orientation)\r\n\r\n        # Compensate for real-world dynamics\r\n        real_grasp.approach_speed = self.adjust_approach_speed(sim_grasp.approach_speed)\r\n        real_grasp.grip_force = self.adjust_grip_force(sim_grasp.grip_force)\r\n\r\n        return real_grasp\r\n\r\n    def add_sensor_noise(self, position, noise_std=0.005):\r\n        """Add realistic sensor noise"""\r\n        noise = np.random.normal(0, noise_std, size=position.shape)\r\n        return position + noise\r\n\r\n    def add_orientation_uncertainty(self, orientation, angle_std=0.05):\r\n        """Add orientation uncertainty"""\r\n        # Generate small random rotation\r\n        random_rotation = self.generate_small_rotation(angle_std)\r\n        return self.multiply_quaternions(orientation, random_rotation)\r\n\r\n    def generate_small_rotation(self, std_dev):\r\n        """Generate small random rotation quaternion"""\r\n        # Generate random axis-angle representation\r\n        axis = np.random.randn(3)\r\n        axis = axis / np.linalg.norm(axis)  # Normalize\r\n        angle = np.random.normal(0, std_dev)\r\n\r\n        # Convert to quaternion\r\n        half_angle = angle / 2\r\n        w = np.cos(half_angle)\r\n        x = axis[0] * np.sin(half_angle)\r\n        y = axis[1] * np.sin(half_angle)\r\n        z = axis[2] * np.sin(half_angle)\r\n\r\n        return np.array([w, x, y, z])\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-manipulation-systems",children:"Best Practices for Manipulation Systems"}),"\n",(0,i.jsx)(n.h3,{id:"1-safety-considerations",children:"1. Safety Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement force limits to prevent damage"}),"\n",(0,i.jsx)(n.li,{children:"Use collision detection and avoidance"}),"\n",(0,i.jsx)(n.li,{children:"Plan safe trajectories that avoid obstacles"}),"\n",(0,i.jsx)(n.li,{children:"Implement emergency stop procedures"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-robustness",children:"2. Robustness"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Handle sensor noise and uncertainty"}),"\n",(0,i.jsx)(n.li,{children:"Implement failure detection and recovery"}),"\n",(0,i.jsx)(n.li,{children:"Use multiple grasp candidates as backup"}),"\n",(0,i.jsx)(n.li,{children:"Verify grasp success before proceeding"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-efficiency",children:"3. Efficiency"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Optimize grasp planning algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Use pre-computed grasp libraries for common objects"}),"\n",(0,i.jsx)(n.li,{children:"Implement adaptive control for different materials"}),"\n",(0,i.jsx)(n.li,{children:"Parallelize computation where possible"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-calibration",children:"4. Calibration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Regularly calibrate force/torque sensors"}),"\n",(0,i.jsx)(n.li,{children:"Maintain accurate robot kinematic models"}),"\n",(0,i.jsx)(n.li,{children:"Calibrate camera-robot coordinate transformations"}),"\n",(0,i.jsx)(n.li,{children:"Validate grasp success rates regularly"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,i.jsx)(n.h3,{id:"1-grasp-failures",children:"1. Grasp Failures"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Verify object pose estimation accuracy"}),"\n",(0,i.jsx)(n.li,{children:"Check gripper calibration"}),"\n",(0,i.jsx)(n.li,{children:"Validate grasp planning parameters"}),"\n",(0,i.jsx)(n.li,{children:"Implement grasp verification routines"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-collision-issues",children:"2. Collision Issues"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Verify collision models are accurate"}),"\n",(0,i.jsx)(n.li,{children:"Check trajectory planning for completeness"}),"\n",(0,i.jsx)(n.li,{children:"Validate workspace limits"}),"\n",(0,i.jsx)(n.li,{children:"Implement real-time collision avoidance"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-force-control-problems",children:"3. Force Control Problems"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Calibrate force/torque sensors regularly"}),"\n",(0,i.jsx)(n.li,{children:"Verify impedance parameters are appropriate"}),"\n",(0,i.jsx)(n.li,{children:"Check for mechanical issues in the robot"}),"\n",(0,i.jsx)(n.li,{children:"Validate control loop timing"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Robotic manipulation and grasping are complex tasks that require integration of perception, planning, control, and learning. The NVIDIA Isaac Platform provides comprehensive tools and frameworks for developing sophisticated manipulation systems that can operate reliably in real-world environments."}),"\n",(0,i.jsx)(n.p,{children:"Key aspects of effective manipulation include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Robust grasp planning with quality assessment"}),"\n",(0,i.jsx)(n.li,{children:"Advanced motion planning with collision avoidance"}),"\n",(0,i.jsx)(n.li,{children:"Force control for compliant manipulation"}),"\n",(0,i.jsx)(n.li,{children:"Learning-based approaches for adaptability"}),"\n",(0,i.jsx)(n.li,{children:"Proper sim-to-real transfer considerations"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the next section, we'll explore reinforcement learning techniques for robot control."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var a=r(6540);const i={},s=a.createContext(i);function t(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);