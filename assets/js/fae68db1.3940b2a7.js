"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[4086],{576:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module4/kinematics","title":"Humanoid Robot Kinematics","description":"Introduction to Humanoid Kinematics","source":"@site/docs/module4/kinematics.md","sourceDirName":"module4","slug":"/module4/kinematics","permalink":"/Physical-AI-Humanoid-book/docs/module4/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/user/physical-ai-humanoid-robotics/tree/main/docs/module4/kinematics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Humanoid Robotics","permalink":"/Physical-AI-Humanoid-book/docs/module4/introduction"},"next":{"title":"Practical Lab: Building a Humanoid Robot Controller","permalink":"/Physical-AI-Humanoid-book/docs/module4/lab-humanoid-controller"}}');var o=i(4848),a=i(8453);const r={},s="Humanoid Robot Kinematics",l={},c=[{value:"Introduction to Humanoid Kinematics",id:"introduction-to-humanoid-kinematics",level:2},{value:"Humanoid Robot Structure and Joint Configuration",id:"humanoid-robot-structure-and-joint-configuration",level:2},{value:"Typical Humanoid DOF Distribution",id:"typical-humanoid-dof-distribution",level:3},{value:"Common Humanoid Topologies",id:"common-humanoid-topologies",level:3},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Mathematical Representation",id:"mathematical-representation",level:3},{value:"Denavit-Hartenberg (DH) Convention",id:"denavit-hartenberg-dh-convention",level:3},{value:"Example: 6-DOF Arm Forward Kinematics",id:"example-6-dof-arm-forward-kinematics",level:3},{value:"Humanoid Multi-Chain Forward Kinematics",id:"humanoid-multi-chain-forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Mathematical Formulation",id:"mathematical-formulation",level:3},{value:"Analytical vs. Numerical Methods",id:"analytical-vs-numerical-methods",level:3},{value:"Analytical IK",id:"analytical-ik",level:4},{value:"Numerical IK",id:"numerical-ik",level:4},{value:"Jacobian-Based Methods",id:"jacobian-based-methods",level:3},{value:"Humanoid-Specific Kinematic Considerations",id:"humanoid-specific-kinematic-considerations",level:2},{value:"Redundancy Resolution",id:"redundancy-resolution",level:3},{value:"Whole-Body Kinematics",id:"whole-body-kinematics",level:3},{value:"Kinematic Constraints and Limitations",id:"kinematic-constraints-and-limitations",level:2},{value:"Joint Limits",id:"joint-limits",level:3},{value:"Singularity Avoidance",id:"singularity-avoidance",level:3},{value:"Implementation Example: Humanoid Arm Control",id:"implementation-example-humanoid-arm-control",level:2},{value:"Best Practices for Humanoid Kinematics",id:"best-practices-for-humanoid-kinematics",level:2},{value:"1. Modular Design",id:"1-modular-design",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Performance Optimization",id:"3-performance-optimization",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"humanoid-robot-kinematics",children:"Humanoid Robot Kinematics"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-humanoid-kinematics",children:"Introduction to Humanoid Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Kinematics is the study of motion without considering the forces that cause the motion. In humanoid robotics, kinematics is crucial for understanding and controlling the complex movements of robots with human-like structures. Humanoid robots typically have 20-50+ degrees of freedom (DOF), making their kinematic analysis significantly more complex than simpler robotic systems."}),"\n",(0,o.jsx)(e.h2,{id:"humanoid-robot-structure-and-joint-configuration",children:"Humanoid Robot Structure and Joint Configuration"}),"\n",(0,o.jsx)(e.h3,{id:"typical-humanoid-dof-distribution",children:"Typical Humanoid DOF Distribution"}),"\n",(0,o.jsx)(e.p,{children:"A standard humanoid robot typically has the following joint distribution:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Total DOF: ~30-40 (varies by platform)\n\nHead: 2-3 DOF\n\u251c\u2500\u2500 Neck pitch/yaw (2 DOF) or neck pitch/yaw/roll (3 DOF)\n\nArms (each): 6-7 DOF\n\u251c\u2500\u2500 Shoulder: 3 DOF (pitch/yaw/roll)\n\u251c\u2500\u2500 Elbow: 1 DOF (pitch)\n\u251c\u2500\u2500 Wrist: 2-3 DOF (pitch/yaw + roll)\n\u2514\u2500\u2500 Hand: 0-16 DOF (varies greatly by design)\n\nTorso: 0-3 DOF\n\u251c\u2500\u2500 Waist: 0-3 DOF (pitch/yaw/roll)\n\nLegs (each): 6-7 DOF\n\u251c\u2500\u2500 Hip: 3 DOF (pitch/yaw/roll)\n\u251c\u2500\u2500 Knee: 1 DOF (pitch)\n\u2514\u2500\u2500 Ankle: 2-3 DOF (pitch/yaw + roll)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"common-humanoid-topologies",children:"Common Humanoid Topologies"}),"\n",(0,o.jsx)(e.p,{children:"Different humanoid platforms have different topologies:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Nao (Aldebaran)"}),": 25 DOF, compact design"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"HUBO (KAIST)"}),": 41 DOF, full human-like structure"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"HRP-4 (AIST)"}),": 37 DOF, adult-sized humanoid"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ATLAS (Boston Dynamics)"}),": 28 DOF, optimized for specific tasks"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Forward kinematics calculates the position and orientation of the end-effector given the joint angles. For humanoid robots, this involves multiple end-effectors (hands, feet)."}),"\n",(0,o.jsx)(e.h3,{id:"mathematical-representation",children:"Mathematical Representation"}),"\n",(0,o.jsx)(e.p,{children:"For a humanoid robot with n joints, the forward kinematics for any link i can be expressed as:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"T_i = T_0 * A_1(\u03b8_1) * A_2(\u03b8_2) * ... * A_i(\u03b8_i)\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"T_i"})," is the transformation matrix of link i relative to the base"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"T_0"})," is the base transformation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"A_j(\u03b8_j)"})," is the transformation matrix of joint j"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"denavit-hartenberg-dh-convention",children:"Denavit-Hartenberg (DH) Convention"}),"\n",(0,o.jsx)(e.p,{children:"The DH convention is commonly used to define coordinate frames for each joint:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"A_i = [cos(\u03b8_i)   -sin(\u03b8_i)*cos(\u03b1_i)   sin(\u03b8_i)*sin(\u03b1_i)   a_i*cos(\u03b8_i)]\n      [sin(\u03b8_i)    cos(\u03b8_i)*cos(\u03b1_i)  -cos(\u03b8_i)*sin(\u03b1_i)   a_i*sin(\u03b8_i)]\n      [0           sin(\u03b1_i)            cos(\u03b1_i)            d_i        ]\n      [0           0                   0                   1          ]\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"\u03b8_i"})," is the joint angle"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"d_i"})," is the link offset"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"a_i"})," is the link length"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"\u03b1_i"})," is the link twist"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"example-6-dof-arm-forward-kinematics",children:"Example: 6-DOF Arm Forward Kinematics"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom math import sin, cos\n\ndef dh_transform(theta, d, a, alpha):\n    """Calculate DH transformation matrix"""\n    return np.array([\n        [cos(theta), -sin(theta)*cos(alpha), sin(theta)*sin(alpha), a*cos(theta)],\n        [sin(theta), cos(theta)*cos(alpha), -cos(theta)*sin(alpha), a*sin(theta)],\n        [0, sin(alpha), cos(alpha), d],\n        [0, 0, 0, 1]\n    ])\n\ndef forward_kinematics_arm(joint_angles):\n    """Calculate forward kinematics for a 6-DOF arm"""\n    # DH parameters for a typical 6-DOF arm\n    dh_params = [\n        (joint_angles[0], 0.1, 0, -np.pi/2),  # Joint 1\n        (joint_angles[1], 0, 0.3, 0),         # Joint 2\n        (joint_angles[2], 0, 0, -np.pi/2),    # Joint 3\n        (joint_angles[3], 0.25, 0, np.pi/2),  # Joint 4\n        (joint_angles[4], 0, 0, -np.pi/2),    # Joint 5\n        (joint_angles[5], 0.08, 0, 0)         # Joint 6\n    ]\n\n    T = np.eye(4)  # Identity transformation\n\n    for theta, d, a, alpha in dh_params:\n        A = dh_transform(theta, d, a, alpha)\n        T = np.dot(T, A)\n\n    return T\n\ndef get_end_effector_pose(joint_angles):\n    """Get position and orientation of end-effector"""\n    T = forward_kinematics_arm(joint_angles)\n\n    # Extract position\n    position = T[:3, 3]\n\n    # Extract orientation (as rotation matrix)\n    orientation = T[:3, :3]\n\n    return position, orientation\n'})}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-multi-chain-forward-kinematics",children:"Humanoid Multi-Chain Forward Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robots, we need to calculate forward kinematics for multiple kinematic chains:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class HumanoidKinematics:\n    def __init__(self):\n        # Define DH parameters for each chain\n        self.left_arm_dh = self.define_arm_dh()\n        self.right_arm_dh = self.define_arm_dh()\n        self.left_leg_dh = self.define_leg_dh()\n        self.right_leg_dh = self.define_leg_dh()\n\n    def define_arm_dh(self):\n        """Define DH parameters for arm"""\n        # Simplified 7-DOF arm (shoulder + elbow + wrist)\n        return [\n            (0, 0.1, 0, -np.pi/2),      # Shoulder pitch\n            (0, 0, 0.3, 0),             # Shoulder yaw\n            (0, 0, 0, 0),               # Shoulder roll\n            (0, 0.25, 0, np.pi/2),      # Elbow\n            (0, 0, 0, -np.pi/2),        # Wrist pitch\n            (0, 0.08, 0, 0),            # Wrist yaw\n            (0, 0, 0, 0)                # Wrist roll\n        ]\n\n    def define_leg_dh(self):\n        """Define DH parameters for leg"""\n        # Simplified 6-DOF leg (hip + knee + ankle)\n        return [\n            (0, 0.1, 0, -np.pi/2),      # Hip roll\n            (0, 0, 0, -np.pi/2),        # Hip pitch\n            (0, 0, 0.4, 0),             # Hip yaw\n            (0, 0.35, 0, 0),            # Knee\n            (0, 0, 0, -np.pi/2),        # Ankle pitch\n            (0, 0.05, 0, 0)             # Ankle roll\n        ]\n\n    def forward_kinematics_arm(self, joint_angles, dh_params):\n        """Calculate forward kinematics for arm"""\n        if len(joint_angles) != len(dh_params):\n            raise ValueError("Joint angles and DH parameters must have same length")\n\n        T = np.eye(4)\n\n        for i, (theta, d, a, alpha) in enumerate(dh_params):\n            A = dh_transform(theta + joint_angles[i], d, a, alpha)\n            T = np.dot(T, A)\n\n        return T\n\n    def get_all_end_effectors(self, joint_angles):\n        """Get positions of all end-effectors"""\n        # Extract joint angles for each chain\n        left_arm_joints = joint_angles[0:7]\n        right_arm_joints = joint_angles[7:14]\n        left_leg_joints = joint_angles[14:20]\n        right_leg_joints = joint_angles[20:26]\n\n        # Calculate end-effector positions\n        left_hand_pose = self.forward_kinematics_arm(left_arm_joints, self.left_arm_dh)\n        right_hand_pose = self.forward_kinematics_arm(right_arm_joints, self.right_arm_dh)\n        left_foot_pose = self.forward_kinematics_arm(left_leg_joints, self.left_leg_dh)\n        right_foot_pose = self.forward_kinematics_arm(right_leg_joints, self.right_leg_dh)\n\n        return {\n            \'left_hand\': left_hand_pose,\n            \'right_hand\': right_hand_pose,\n            \'left_foot\': left_foot_pose,\n            \'right_foot\': right_foot_pose\n        }\n'})}),"\n",(0,o.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Inverse kinematics (IK) is the process of determining the joint angles required to achieve a desired end-effector position and orientation. This is more challenging than forward kinematics and often has multiple solutions or no solutions."}),"\n",(0,o.jsx)(e.h3,{id:"mathematical-formulation",children:"Mathematical Formulation"}),"\n",(0,o.jsxs)(e.p,{children:["For a given end-effector pose ",(0,o.jsx)(e.code,{children:"T_d"}),", we want to find joint angles ",(0,o.jsx)(e.code,{children:"\u03b8"})," such that:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"f(\u03b8) = T_d\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Where ",(0,o.jsx)(e.code,{children:"f"})," represents the forward kinematics function."]}),"\n",(0,o.jsx)(e.h3,{id:"analytical-vs-numerical-methods",children:"Analytical vs. Numerical Methods"}),"\n",(0,o.jsx)(e.h4,{id:"analytical-ik",children:"Analytical IK"}),"\n",(0,o.jsx)(e.p,{children:"Analytical solutions exist for simple kinematic chains (like 6-DOF arms with specific geometries):"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def analytical_ik_6dof(position, orientation):\n    """\n    Analytical inverse kinematics for a 6-DOF arm with specific geometry\n    Assumes spherical wrist (last 3 joints intersect at a point)\n    """\n    px, py, pz = position\n\n    # Calculate wrist center position\n    # Assuming tool frame offset\n    tool_length = 0.1\n    wrist_center_x = px - tool_length * orientation[0, 2]\n    wrist_center_y = py - tool_length * orientation[1, 2]\n    wrist_center_z = pz - tool_length * orientation[2, 2]\n\n    # Calculate first three joints (position)\n    theta1 = np.arctan2(wrist_center_y, wrist_center_x)\n\n    # Calculate distance from joint 2 to wrist center\n    r = np.sqrt(wrist_center_x**2 + wrist_center_y**2)\n    d = wrist_center_z - 0.1  # height of joint 2\n\n    # Calculate remaining joint angles using geometric approach\n    # This is simplified - full solution would be more complex\n    theta2 = np.arctan2(d, r)\n    theta3 = 0  # Simplified\n\n    # Calculate last three joints (orientation) using wrist approach\n    theta4, theta5, theta6 = calculate_wrist_angles(orientation, theta1, theta2, theta3)\n\n    return [theta1, theta2, theta3, theta4, theta5, theta6]\n\ndef calculate_wrist_angles(orientation, theta1, theta2, theta3):\n    """Calculate wrist joint angles for desired orientation"""\n    # Calculate rotation matrix from first 3 joints\n    # Then solve for wrist joint angles\n    # Implementation depends on specific arm geometry\n    pass\n'})}),"\n",(0,o.jsx)(e.h4,{id:"numerical-ik",children:"Numerical IK"}),"\n",(0,o.jsx)(e.p,{children:"For complex kinematic chains like humanoid robots, numerical methods are typically used:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import scipy.optimize as opt\n\nclass NumericalIK:\n    def __init__(self, robot_kinematics):\n        self.kinematics = robot_kinematics\n\n    def ik_objective(self, joint_angles, target_pose, chain_dh):\n        """Objective function for IK optimization"""\n        current_pose = self.kinematics.forward_kinematics_arm(joint_angles, chain_dh)\n\n        # Calculate position error\n        pos_error = np.linalg.norm(target_pose[:3, 3] - current_pose[:3, 3])\n\n        # Calculate orientation error (using rotation matrix difference)\n        R_current = current_pose[:3, :3]\n        R_target = target_pose[:3, :3]\n\n        # Frobenius norm of rotation difference\n        R_diff = R_target - R_current\n        rot_error = np.linalg.norm(R_diff, \'fro\')\n\n        # Weighted combination of position and orientation errors\n        total_error = pos_error + 0.1 * rot_error\n\n        return total_error\n\n    def solve_ik(self, target_pose, initial_guess, chain_dh, joint_limits=None):\n        """Solve inverse kinematics using numerical optimization"""\n        if joint_limits is None:\n            # Default joint limits (\xb1\u03c0 for all joints)\n            joint_limits = [(-np.pi, np.pi)] * len(initial_guess)\n\n        # Define bounds\n        bounds = opt.Bounds(\n            [lim[0] for lim in joint_limits],\n            [lim[1] for lim in joint_limits]\n        )\n\n        # Solve optimization problem\n        result = opt.minimize(\n            self.ik_objective,\n            initial_guess,\n            args=(target_pose, chain_dh),\n            method=\'L-BFGS-B\',\n            bounds=bounds\n        )\n\n        if result.success:\n            return result.x\n        else:\n            raise Exception(f"IK solution failed: {result.message}")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"jacobian-based-methods",children:"Jacobian-Based Methods"}),"\n",(0,o.jsx)(e.p,{children:"The Jacobian matrix relates joint velocities to end-effector velocities:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"v_e = J(\u03b8) * \u03b8\u0307\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v_e"})," is the end-effector velocity vector"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"J(\u03b8)"})," is the Jacobian matrix"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"\u03b8\u0307"})," is the joint velocity vector"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def calculate_jacobian(robot_kinematics, joint_angles, link_index):\n    """Calculate geometric Jacobian for a given link"""\n    n = len(joint_angles)\n    J = np.zeros((6, n))  # 6 DOF (3 position, 3 orientation)\n\n    # Get current transformation for the link\n    T_current = robot_kinematics.forward_kinematics_arm(joint_angles[:link_index+1],\n                                                        robot_kinematics.get_dh_params()[:link_index+1])\n    current_pos = T_current[:3, 3]\n    current_rot = T_current[:3, :3]\n\n    # Calculate Jacobian columns\n    for i in range(n):\n        if i <= link_index:\n            # Get joint axis in world coordinates\n            T_to_joint = robot_kinematics.forward_kinematics_arm(joint_angles[:i+1],\n                                                                robot_kinematics.get_dh_params()[:i+1])\n            joint_axis_world = T_to_joint[:3, :3] @ np.array([0, 0, 1])  # Assuming z-axis joints\n            joint_pos = T_to_joint[:3, 3]\n\n            # Position part of Jacobian\n            J[:3, i] = np.cross(joint_axis_world, current_pos - joint_pos)\n\n            # Orientation part of Jacobian\n            J[3:, i] = joint_axis_world\n\n    return J\n\ndef jacobian_ik_step(jacobian, error, alpha=0.5):\n    """Calculate joint angle update using Jacobian pseudoinverse"""\n    # Use damped least squares to avoid singularities\n    damping = 0.01\n    I = np.eye(jacobian.shape[1])\n\n    # Damped pseudoinverse\n    J_pinv = jacobian.T @ np.linalg.inv(jacobian @ jacobian.T + damping**2 * I)\n\n    # Calculate joint angle update\n    delta_theta = alpha * J_pinv @ error\n\n    return delta_theta\n'})}),"\n",(0,o.jsx)(e.h2,{id:"humanoid-specific-kinematic-considerations",children:"Humanoid-Specific Kinematic Considerations"}),"\n",(0,o.jsx)(e.h3,{id:"redundancy-resolution",children:"Redundancy Resolution"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots often have redundant DOF (more joints than necessary for a task). This redundancy can be resolved using various techniques:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def resolve_redundancy(joint_angles, joint_centers, weights):\n    """\n    Resolve redundancy by moving toward joint centers\n    Uses null-space projection to maintain end-effector position\n    """\n    # Calculate joint centering objective\n    centering_term = np.zeros_like(joint_angles)\n\n    for i in range(len(joint_angles)):\n        centering_term[i] = weights[i] * (joint_centers[i] - joint_angles[i])\n\n    return centering_term\n\ndef null_space_projection(jacobian, joint_angles, joint_centers, weights):\n    """Project redundancy resolution into null space of Jacobian"""\n    J = jacobian\n    I = np.eye(J.shape[1])\n\n    # Calculate pseudoinverse\n    J_pinv = np.linalg.pinv(J)\n\n    # Calculate null space projection matrix\n    null_space_proj = I - J_pinv @ J\n\n    # Calculate redundancy resolution term\n    redundancy_term = resolve_redundancy(joint_angles, joint_centers, weights)\n\n    # Project into null space\n    null_space_motion = null_space_proj @ redundancy_term\n\n    return null_space_motion\n'})}),"\n",(0,o.jsx)(e.h3,{id:"whole-body-kinematics",children:"Whole-Body Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots require whole-body kinematic solutions that consider all kinematic chains simultaneously:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class WholeBodyKinematics:\n    def __init__(self):\n        self.kinematics = HumanoidKinematics()\n        self.support_polygon = None\n\n    def solve_whole_body_ik(self, tasks, current_angles, weights=None):\n        \"\"\"\n        Solve whole-body inverse kinematics with multiple tasks\n        Tasks: list of (end_effector_name, target_pose, priority)\n        \"\"\"\n        if weights is None:\n            weights = np.ones(len(current_angles))  # Default weights\n\n        # Define optimization problem with multiple tasks\n        def objective(joint_angles):\n            total_error = 0\n\n            for task_name, target_pose, priority in tasks:\n                if task_name == 'left_hand':\n                    current_pose = self.kinematics.forward_kinematics_arm(\n                        joint_angles[0:7], self.kinematics.left_arm_dh\n                    )\n                elif task_name == 'right_hand':\n                    current_pose = self.kinematics.forward_kinematics_arm(\n                        joint_angles[7:14], self.kinematics.right_arm_dh\n                    )\n                elif task_name == 'left_foot':\n                    current_pose = self.kinematics.forward_kinematics_arm(\n                        joint_angles[14:20], self.kinematics.left_leg_dh\n                    )\n                elif task_name == 'right_foot':\n                    current_pose = self.kinematics.forward_kinematics_arm(\n                        joint_angles[20:26], self.kinematics.right_leg_dh\n                    )\n\n                # Calculate task error\n                pos_error = np.linalg.norm(target_pose[:3, 3] - current_pose[:3, 3])\n                total_error += priority * pos_error\n\n            # Add joint centering term\n            centering_error = 0.01 * np.sum(weights * (joint_angles - 0)**2)\n            total_error += centering_error\n\n            return total_error\n\n        # Solve optimization problem\n        result = opt.minimize(\n            objective,\n            current_angles,\n            method='L-BFGS-B'\n        )\n\n        return result.x if result.success else current_angles\n"})}),"\n",(0,o.jsx)(e.h2,{id:"kinematic-constraints-and-limitations",children:"Kinematic Constraints and Limitations"}),"\n",(0,o.jsx)(e.h3,{id:"joint-limits",children:"Joint Limits"}),"\n",(0,o.jsx)(e.p,{children:"Joint limits must be respected in all kinematic calculations:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def enforce_joint_limits(joint_angles, min_limits, max_limits):\n    """Enforce joint limits on calculated joint angles"""\n    limited_angles = np.copy(joint_angles)\n\n    for i in range(len(joint_angles)):\n        limited_angles[i] = np.clip(joint_angles[i], min_limits[i], max_limits[i])\n\n    return limited_angles\n\ndef check_joint_limits(joint_angles, min_limits, max_limits):\n    """Check if joint angles are within limits"""\n    for i in range(len(joint_angles)):\n        if joint_angles[i] < min_limits[i] or joint_angles[i] > max_limits[i]:\n            return False\n    return True\n'})}),"\n",(0,o.jsx)(e.h3,{id:"singularity-avoidance",children:"Singularity Avoidance"}),"\n",(0,o.jsx)(e.p,{children:"Singular configurations should be avoided as they lead to loss of DOF:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def calculate_condition_number(jacobian):\n    """Calculate condition number to detect singularities"""\n    U, s, Vh = np.linalg.svd(jacobian)\n    return s[0] / s[-1] if s[-1] != 0 else float(\'inf\')\n\ndef is_near_singular(jacobian, threshold=100):\n    """Check if Jacobian is near singular"""\n    cond_num = calculate_condition_number(jacobian)\n    return cond_num > threshold\n\ndef add_singular_perturbation(joint_angles, jacobian, target_pose):\n    """Add small perturbation to move away from singular configuration"""\n    if is_near_singular(jacobian):\n        # Add small random perturbation\n        perturbation = np.random.normal(0, 0.01, size=joint_angles.shape)\n        return joint_angles + perturbation\n    return joint_angles\n'})}),"\n",(0,o.jsx)(e.h2,{id:"implementation-example-humanoid-arm-control",children:"Implementation Example: Humanoid Arm Control"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class HumanoidArmController:\n    def __init__(self, side=\'right\'):\n        self.side = side\n        self.kinematics = HumanoidKinematics()\n        self.current_angles = np.zeros(7)  # 7 DOF arm\n        self.joint_limits = [(-2.967, 2.967)] * 7  # Example limits\n\n        # Joint center positions for redundancy resolution\n        self.joint_centers = np.array([0, 0, 0, 0, 0, 0, 0])\n        self.centering_weights = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05, 0.05])\n\n    def move_to_pose(self, target_position, target_orientation):\n        """Move arm to target pose"""\n        # Create target pose transformation matrix\n        target_pose = np.eye(4)\n        target_pose[:3, 3] = target_position\n        target_pose[:3, :3] = target_orientation\n\n        # Solve inverse kinematics\n        try:\n            new_angles = self.solve_ik(target_pose)\n\n            # Apply joint limits\n            new_angles = enforce_joint_limits(new_angles,\n                                            [lim[0] for lim in self.joint_limits],\n                                            [lim[1] for lim in self.joint_limits])\n\n            # Update current angles\n            self.current_angles = new_angles\n\n            return True, new_angles\n        except Exception as e:\n            print(f"Failed to move to pose: {e}")\n            return False, self.current_angles\n\n    def solve_ik(self, target_pose):\n        """Solve inverse kinematics for target pose"""\n        # Use numerical method with initial guess\n        initial_guess = self.current_angles\n\n        # Set up optimization with multiple objectives\n        def objective(angles):\n            # Calculate current pose\n            current_pose = self.kinematics.forward_kinematics_arm(\n                angles,\n                self.kinematics.right_arm_dh if self.side == \'right\' else self.kinematics.left_arm_dh\n            )\n\n            # Position error\n            pos_error = np.linalg.norm(target_pose[:3, 3] - current_pose[:3, 3])\n\n            # Orientation error\n            R_diff = target_pose[:3, :3] - current_pose[:3, :3]\n            rot_error = np.linalg.norm(R_diff, \'fro\')\n\n            # Joint centering (redundancy resolution)\n            centering_error = np.sum(self.centering_weights * (angles - self.joint_centers)**2)\n\n            # Total objective\n            total_error = pos_error + 0.1 * rot_error + 0.01 * centering_error\n\n            return total_error\n\n        # Solve optimization\n        result = opt.minimize(\n            objective,\n            initial_guess,\n            method=\'L-BFGS-B\',\n            bounds=self.joint_limits\n        )\n\n        if result.success:\n            return result.x\n        else:\n            raise Exception(f"IK solution failed: {result.message}")\n\n    def get_current_pose(self):\n        """Get current end-effector pose"""\n        current_pose = self.kinematics.forward_kinematics_arm(\n            self.current_angles,\n            self.kinematics.right_arm_dh if self.side == \'right\' else self.kinematics.left_arm_dh\n        )\n\n        position = current_pose[:3, 3]\n        orientation = current_pose[:3, :3]\n\n        return position, orientation\n'})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices-for-humanoid-kinematics",children:"Best Practices for Humanoid Kinematics"}),"\n",(0,o.jsx)(e.h3,{id:"1-modular-design",children:"1. Modular Design"}),"\n",(0,o.jsx)(e.p,{children:"Design kinematic functions to be modular and reusable:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Separate forward and inverse kinematics into distinct modules\n# Allow for easy swapping of algorithms\n# Provide consistent interfaces\n"})}),"\n",(0,o.jsx)(e.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,o.jsx)(e.p,{children:"Always include proper error handling for kinematic calculations:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def safe_ik_solution(target_pose, current_angles):\n    """Safely solve IK with error handling"""\n    try:\n        solution = solve_ik(target_pose, current_angles)\n\n        # Verify solution\n        if verify_ik_solution(target_pose, solution):\n            return solution\n        else:\n            raise ValueError("IK solution verification failed")\n    except Exception as e:\n        print(f"IK error: {e}")\n        return current_angles  # Return current angles if failed\n'})}),"\n",(0,o.jsx)(e.h3,{id:"3-performance-optimization",children:"3. Performance Optimization"}),"\n",(0,o.jsx)(e.p,{children:"For real-time humanoid control, optimize kinematic calculations:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Use efficient numerical libraries (NumPy, SciPy)\n# Cache transformation matrices when possible\n# Use analytical solutions when available\n# Consider approximate methods for real-time applications\n"})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robot kinematics is a complex but fundamental aspect of humanoid robotics. Understanding both forward and inverse kinematics is essential for controlling these multi-DOF systems effectively. The redundancy inherent in humanoid robots provides both opportunities (for obstacle avoidance, joint centering) and challenges (multiple solutions, singularity avoidance) that must be carefully managed."}),"\n",(0,o.jsx)(e.p,{children:"Key takeaways from this section include:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Forward kinematics"})," provides the mathematical foundation for determining end-effector positions from joint angles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Inverse kinematics"})," is typically solved using numerical methods for complex humanoid structures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Redundancy resolution"})," is crucial for managing the extra DOF in humanoid robots"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Constraint handling"})," for joint limits, singularities, and other physical constraints is essential"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Whole-body coordination"})," requires considering all kinematic chains simultaneously"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"In the next section, we'll explore the dynamics and control aspects of humanoid robots, which build upon the kinematic foundation established here."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);