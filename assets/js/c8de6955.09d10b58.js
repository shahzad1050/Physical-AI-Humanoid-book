"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[8438],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}},8948:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module3/lab-ai-robot","title":"Practical Lab: Building an AI-Powered Robot","description":"Objective","source":"@site/docs/module3/lab-ai-robot.md","sourceDirName":"module3","slug":"/module3/lab-ai-robot","permalink":"/Physical-AI-Humanoid-book/docs/module3/lab-ai-robot","draft":false,"unlisted":false,"editUrl":"https://github.com/user/physical-ai-humanoid-robotics/tree/main/docs/module3/lab-ai-robot.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Isaac Sim for Advanced Simulation","permalink":"/Physical-AI-Humanoid-book/docs/module3/isaac-sim"},"next":{"title":"Manipulation and Grasping","permalink":"/Physical-AI-Humanoid-book/docs/module3/manipulation-grasping"}}');var i=r(4848),o=r(8453);const a={},s="Practical Lab: Building an AI-Powered Robot",l={},c=[{value:"Objective",id:"objective",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Project Setup and Environment Configuration",id:"step-1-project-setup-and-environment-configuration",level:2},{value:"Step 2: Create the Robot URDF Model",id:"step-2-create-the-robot-urdf-model",level:2},{value:"Step 3: Create the Perception Node",id:"step-3-create-the-perception-node",level:2},{value:"Step 4: Create the Navigation Node",id:"step-4-create-the-navigation-node",level:2},{value:"Step 5: Create the Manipulation Node",id:"step-5-create-the-manipulation-node",level:2},{value:"Step 6: Create the Main Control Node",id:"step-6-create-the-main-control-node",level:2},{value:"Step 7: Create Launch Files",id:"step-7-create-launch-files",level:2},{value:"Step 8: Update setup.py",id:"step-8-update-setuppy",level:2},{value:"Step 9: Create a Simulation Environment",id:"step-9-create-a-simulation-environment",level:2},{value:"Step 10: Build and Run the System",id:"step-10-build-and-run-the-system",level:2},{value:"Step 11: Testing and Validation",id:"step-11-testing-and-validation",level:2},{value:"Expected Results",id:"expected-results",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"practical-lab-building-an-ai-powered-robot",children:"Practical Lab: Building an AI-Powered Robot"})}),"\n",(0,i.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,i.jsx)(n.p,{children:"In this lab, you will create a complete AI-powered robot system using the NVIDIA Isaac Platform. You will design a robot with perception capabilities, implement AI-based control algorithms, and create a complete pipeline that integrates simulation and real-world deployment considerations."}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Completed all previous modules (ROS 2, Simulation, Isaac Platform)"}),"\n",(0,i.jsx)(n.li,{children:"Access to Isaac Sim (Omniverse or Docker)"}),"\n",(0,i.jsx)(n.li,{children:"NVIDIA GPU with CUDA support (recommended: RTX 3080 or better)"}),"\n",(0,i.jsx)(n.li,{children:"Basic understanding of Python and C++"}),"\n",(0,i.jsx)(n.li,{children:"Familiarity with Docker for Isaac Sim"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"step-1-project-setup-and-environment-configuration",children:"Step 1: Project Setup and Environment Configuration"}),"\n",(0,i.jsx)(n.p,{children:"First, create a workspace for your AI-powered robot project:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Create project directory\r\nmkdir -p ~/isaac_ai_robot_ws/src\r\ncd ~/isaac_ai_robot_ws/src\r\n\r\n# Create a new ROS 2 package for the robot system\r\nros2 pkg create --build-type ament_python ai_robot_system --dependencies rclpy std_msgs sensor_msgs geometry_msgs vision_msgs message_filters cv_bridge tf2_ros\r\n\r\n# Create additional directories for models and configurations\r\nmkdir -p ~/isaac_ai_robot_ws/src/ai_robot_system/config\r\nmkdir -p ~/isaac_ai_robot_ws/src/ai_robot_system/models\r\nmkdir -p ~/isaac_ai_robot_ws/src/ai_robot_system/launch\r\nmkdir -p ~/isaac_ai_robot_ws/src/ai_robot_system/ai_models\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-2-create-the-robot-urdf-model",children:"Step 2: Create the Robot URDF Model"}),"\n",(0,i.jsxs)(n.p,{children:["Create a simple mobile manipulator robot model in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/models/ai_robot.urdf"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="ai_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n  \x3c!-- Robot properties --\x3e\r\n  <xacro:property name="M_PI" value="3.1415926535897931" />\r\n\r\n  \x3c!-- Base link --\x3e\r\n  <link name="base_link">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.3"/>\r\n      </geometry>\r\n      <material name="blue">\r\n        <color rgba="0 0 1 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.3"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="20.0"/>\r\n      <inertia\r\n        ixx="1.0" ixy="0.0" ixz="0.0"\r\n        iyy="1.0" iyz="0.0"\r\n        izz="1.0"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Camera link --\x3e\r\n  <link name="camera_link">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.05 0.05 0.05"/>\r\n      </geometry>\r\n      <material name="black">\r\n        <color rgba="0 0 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.05 0.05 0.05"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia\r\n        ixx="0.001" ixy="0.0" ixz="0.0"\r\n        iyy="0.001" iyz="0.0"\r\n        izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Camera joint --\x3e\r\n  <joint name="camera_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="camera_link"/>\r\n    <origin xyz="0.2 0 0.15" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Arm base link --\x3e\r\n  <link name="arm_base_link">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.1" radius="0.05"/>\r\n      </geometry>\r\n      <material name="gray">\r\n        <color rgba="0.5 0.5 0.5 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.1" radius="0.05"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia\r\n        ixx="0.001" ixy="0.0" ixz="0.0"\r\n        iyy="0.001" iyz="0.0"\r\n        izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Arm base joint --\x3e\r\n  <joint name="arm_base_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="arm_base_link"/>\r\n    <origin xyz="0.1 0 0.1" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- First arm link --\x3e\r\n  <link name="arm_link1">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.02"/>\r\n      </geometry>\r\n      <material name="silver">\r\n        <color rgba="0.75 0.75 0.75 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.02"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia\r\n        ixx="0.001" ixy="0.0" ixz="0.0"\r\n        iyy="0.001" iyz="0.0"\r\n        izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- First arm joint --\x3e\r\n  <joint name="arm_joint1" type="revolute">\r\n    <parent link="arm_base_link"/>\r\n    <child link="arm_link1"/>\r\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="100" velocity="1"/>\r\n  </joint>\r\n\r\n  \x3c!-- Second arm link --\x3e\r\n  <link name="arm_link2">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.25" radius="0.02"/>\r\n      </geometry>\r\n      <material name="silver">\r\n        <color rgba="0.75 0.75 0.75 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.25" radius="0.02"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="0.4"/>\r\n      <inertia\r\n        ixx="0.001" ixy="0.0" ixz="0.0"\r\n        iyy="0.001" iyz="0.0"\r\n        izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Second arm joint --\x3e\r\n  <joint name="arm_joint2" type="revolute">\r\n    <parent link="arm_link1"/>\r\n    <child link="arm_link2"/>\r\n    <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="100" velocity="1"/>\r\n  </joint>\r\n\r\n  \x3c!-- End effector link --\x3e\r\n  <link name="end_effector">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.02 0.02 0.05"/>\r\n      </geometry>\r\n      <material name="red">\r\n        <color rgba="1 0 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.02 0.02 0.05"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia\r\n        ixx="0.0001" ixy="0.0" ixz="0.0"\r\n        iyy="0.0001" iyz="0.0"\r\n        izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- End effector joint --\x3e\r\n  <joint name="ee_joint" type="fixed">\r\n    <parent link="arm_link2"/>\r\n    <child link="end_effector"/>\r\n    <origin xyz="0 0 0.125" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Gazebo plugins --\x3e\r\n  <gazebo>\r\n    \x3c!-- Differential drive plugin for base --\x3e\r\n    <plugin name="differential_drive" filename="libgazebo_ros_diff_drive.so">\r\n      <left_joint>wheel_left_joint</left_joint>\r\n      <right_joint>wheel_right_joint</right_joint>\r\n      <wheel_separation>0.5</wheel_separation>\r\n      <wheel_diameter>0.2</wheel_diameter>\r\n      <command_topic>cmd_vel</command_topic>\r\n      <odometry_topic>odom</odometry_topic>\r\n      <odometry_frame>odom</odometry_frame>\r\n      <robot_base_frame>base_link</robot_base_frame>\r\n    </plugin>\r\n  </gazebo>\r\n\r\n  \x3c!-- Add wheel joints and links here if needed --\x3e\r\n  <link name="wheel_left">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.05" radius="0.1"/>\r\n      </geometry>\r\n      <material name="black">\r\n        <color rgba="0 0 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.05" radius="0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia\r\n        ixx="0.001" ixy="0.0" ixz="0.0"\r\n        iyy="0.001" iyz="0.0"\r\n        izz="0.002"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <link name="wheel_right">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.05" radius="0.1"/>\r\n      </geometry>\r\n      <material name="black">\r\n        <color rgba="0 0 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.05" radius="0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia\r\n        ixx="0.001" ixy="0.0" ixz="0.0"\r\n        iyy="0.001" iyz="0.0"\r\n        izz="0.002"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="wheel_left_joint" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="wheel_left"/>\r\n    <origin xyz="0 0.2 -0.1" rpy="${M_PI/2} 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n  </joint>\r\n\r\n  <joint name="wheel_right_joint" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="wheel_right"/>\r\n    <origin xyz="0 -0.2 -0.1" rpy="${M_PI/2} 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n  </joint>\r\n</robot>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-3-create-the-perception-node",children:"Step 3: Create the Perception Node"}),"\n",(0,i.jsxs)(n.p,{children:["Create the AI perception node in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/ai_robot_system/perception_node.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\n\"\"\"\r\nAI Perception Node\r\nImplements object detection and scene understanding using Isaac GEMs\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, CameraInfo\r\nfrom vision_msgs.msg import Detection2DArray, ObjectHypothesisWithPose\r\nfrom geometry_msgs.msg import Point\r\nfrom cv_bridge import CvBridge\r\nimport cv2\r\nimport numpy as np\r\nimport torch\r\nimport torchvision.transforms as transforms\r\nfrom torchvision.models.detection import fasterrcnn_resnet50_fpn\r\nimport tf2_ros\r\nfrom tf2_ros import TransformException\r\nimport message_filters\r\n\r\n\r\nclass AI PerceptionNode(Node):\r\n    def __init__(self):\r\n        super().__init__('ai_perception_node')\r\n\r\n        # Initialize CV bridge\r\n        self.cv_bridge = CvBridge()\r\n\r\n        # Initialize neural network model\r\n        self.initialize_model()\r\n\r\n        # Create subscribers\r\n        self.image_sub = self.create_subscription(\r\n            Image,\r\n            '/camera/image_raw',\r\n            self.image_callback,\r\n            10\r\n        )\r\n\r\n        self.camera_info_sub = self.create_subscription(\r\n            CameraInfo,\r\n            '/camera/camera_info',\r\n            self.camera_info_callback,\r\n            10\r\n        )\r\n\r\n        # Create publisher for detections\r\n        self.detection_pub = self.create_publisher(\r\n            Detection2DArray,\r\n            '/ai_robot/detections',\r\n            10\r\n        )\r\n\r\n        # Initialize camera parameters\r\n        self.camera_matrix = None\r\n        self.dist_coeffs = None\r\n\r\n        # TF broadcaster and listener\r\n        self.tf_buffer = tf2_ros.Buffer()\r\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\r\n\r\n        self.get_logger().info('AI Perception Node initialized')\r\n\r\n    def initialize_model(self):\r\n        \"\"\"Initialize the AI model for object detection\"\"\"\r\n        try:\r\n            # Load pre-trained model\r\n            self.model = fasterrcnn_resnet50_fpn(pretrained=True)\r\n            self.model.eval()\r\n\r\n            # Define class names (COCO dataset classes)\r\n            self.class_names = [\r\n                '__background__', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus',\r\n                'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign',\r\n                'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',\r\n                'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag',\r\n                'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite',\r\n                'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',\r\n                'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana',\r\n                'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza',\r\n                'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table',\r\n                'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',\r\n                'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock',\r\n                'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'\r\n            ]\r\n\r\n            self.get_logger().info('AI model loaded successfully')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Failed to initialize AI model: {e}')\r\n            # Fallback to a simple detection method\r\n            self.model = None\r\n\r\n    def image_callback(self, msg):\r\n        \"\"\"Process incoming image messages\"\"\"\r\n        try:\r\n            # Convert ROS image to OpenCV format\r\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\r\n\r\n            # Run object detection\r\n            if self.model is not None:\r\n                detections = self.run_object_detection(cv_image)\r\n            else:\r\n                # Fallback: simple color-based detection\r\n                detections = self.fallback_detection(cv_image)\r\n\r\n            # Create detection message\r\n            detection_msg = self.create_detection_message(detections, msg.header)\r\n\r\n            # Publish detections\r\n            self.detection_pub.publish(detection_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing image: {e}')\r\n\r\n    def run_object_detection(self, image):\r\n        \"\"\"Run object detection using the AI model\"\"\"\r\n        # Preprocess image\r\n        transform = transforms.Compose([\r\n            transforms.ToTensor(),\r\n        ])\r\n        input_tensor = transform(image)\r\n        input_batch = input_tensor.unsqueeze(0)\r\n\r\n        # Run inference\r\n        with torch.no_grad():\r\n            outputs = self.model(input_batch)\r\n\r\n        # Process outputs\r\n        detections = []\r\n        for i, (boxes, scores, labels) in enumerate(zip(outputs[0]['boxes'],\r\n                                                        outputs[0]['scores'],\r\n                                                        outputs[0]['labels'])):\r\n            # Filter detections by confidence\r\n            keep = scores > 0.5\r\n            boxes = boxes[keep].cpu().numpy()\r\n            scores = scores[keep].cpu().numpy()\r\n            labels = labels[keep].cpu().numpy()\r\n\r\n            for box, score, label in zip(boxes, scores, labels):\r\n                if label < len(self.class_names):\r\n                    detection = {\r\n                        'bbox': box,\r\n                        'score': score,\r\n                        'class_name': self.class_names[label],\r\n                        'class_id': label\r\n                    }\r\n                    detections.append(detection)\r\n\r\n        return detections\r\n\r\n    def fallback_detection(self, image):\r\n        \"\"\"Fallback detection method using color thresholding\"\"\"\r\n        # Simple red object detection as fallback\r\n        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\r\n\r\n        # Define range for red color\r\n        lower_red = np.array([0, 50, 50])\r\n        upper_red = np.array([10, 255, 255])\r\n        mask1 = cv2.inRange(hsv, lower_red, upper_red)\r\n\r\n        lower_red = np.array([170, 50, 50])\r\n        upper_red = np.array([180, 255, 255])\r\n        mask2 = cv2.inRange(hsv, lower_red, upper_red)\r\n\r\n        mask = mask1 + mask2\r\n\r\n        # Find contours\r\n        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n\r\n        detections = []\r\n        for contour in contours:\r\n            if cv2.contourArea(contour) > 100:  # Filter small contours\r\n                x, y, w, h = cv2.boundingRect(contour)\r\n                detection = {\r\n                    'bbox': [x, y, x + w, y + h],\r\n                    'score': 0.8,  # Fallback confidence\r\n                    'class_name': 'red_object',\r\n                    'class_id': 0\r\n                }\r\n                detections.append(detection)\r\n\r\n        return detections\r\n\r\n    def camera_info_callback(self, msg):\r\n        \"\"\"Update camera calibration parameters\"\"\"\r\n        self.camera_matrix = np.array(msg.k).reshape(3, 3)\r\n        self.dist_coeffs = np.array(msg.d)\r\n\r\n    def create_detection_message(self, detections, header):\r\n        \"\"\"Create Detection2DArray message from detections\"\"\"\r\n        detection_array = Detection2DArray()\r\n        detection_array.header = header\r\n\r\n        for detection in detections:\r\n            detection_2d = Detection2D()\r\n            detection_2d.header = header\r\n\r\n            # Set bounding box\r\n            bbox = detection['bbox']\r\n            detection_2d.bbox.center.x = (bbox[0] + bbox[2]) / 2.0\r\n            detection_2d.bbox.center.y = (bbox[1] + bbox[3]) / 2.0\r\n            detection_2d.bbox.size_x = abs(bbox[2] - bbox[0])\r\n            detection_2d.bbox.size_y = abs(bbox[3] - bbox[1])\r\n\r\n            # Set results\r\n            result = ObjectHypothesisWithPose()\r\n            result.hypothesis.class_id = str(detection['class_name'])\r\n            result.hypothesis.score = float(detection['score'])\r\n            detection_2d.results.append(result)\r\n\r\n            detection_array.detections.append(detection_2d)\r\n\r\n        return detection_array\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = AI PerceptionNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-4-create-the-navigation-node",children:"Step 4: Create the Navigation Node"}),"\n",(0,i.jsxs)(n.p,{children:["Create the navigation node in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/ai_robot_system/navigation_node.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\n"""\r\nAI Navigation Node\r\nImplements autonomous navigation using reinforcement learning\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist, PoseStamped, Point\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom nav_msgs.msg import Odometry\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\nimport numpy as np\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.optim as optim\r\nfrom collections import deque\r\nimport random\r\n\r\n\r\nclass DQN(nn.Module):\r\n    def __init__(self, state_dim, action_dim, hidden_dim=128):\r\n        super(DQN, self).__init__()\r\n        self.network = nn.Sequential(\r\n            nn.Linear(state_dim, hidden_dim),\r\n            nn.ReLU(),\r\n            nn.Linear(hidden_dim, hidden_dim),\r\n            nn.ReLU(),\r\n            nn.Linear(hidden_dim, hidden_dim),\r\n            nn.ReLU(),\r\n            nn.Linear(hidden_dim, action_dim)\r\n        )\r\n\r\n    def forward(self, state):\r\n        return self.network(state)\r\n\r\n\r\nclass NavigationNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'navigation_node\')\r\n\r\n        # Initialize DQN\r\n        self.state_dim = 36 + 3  # 36 laser readings + 3 (x, y, theta)\r\n        self.action_dim = 4  # 4 discrete actions: forward, left, right, stop\r\n        self.q_network = DQN(self.state_dim, self.action_dim)\r\n        self.target_network = DQN(self.state_dim, self.action_dim)\r\n        self.optimizer = optim.Adam(self.q_network.parameters(), lr=1e-3)\r\n\r\n        self.target_network.load_state_dict(self.q_network.state_dict())\r\n\r\n        # Training parameters\r\n        self.gamma = 0.95\r\n        self.epsilon = 1.0\r\n        self.epsilon_decay = 0.995\r\n        self.epsilon_min = 0.01\r\n        self.batch_size = 32\r\n\r\n        # Replay buffer\r\n        self.memory = deque(maxlen=10000)\r\n\r\n        # Current state\r\n        self.current_scan = None\r\n        self.current_odom = None\r\n        self.target_position = np.array([5.0, 5.0])  # Target coordinates\r\n\r\n        # Create publishers and subscribers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.scan_sub = self.create_subscription(LaserScan, \'/scan\', self.scan_callback, 10)\r\n        self.odom_sub = self.create_subscription(Odometry, \'/odom\', self.odom_callback, 10)\r\n\r\n        # Create timer for navigation loop\r\n        self.nav_timer = self.create_timer(0.1, self.navigation_loop)\r\n\r\n        # Initialize TF\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        self.get_logger().info(\'AI Navigation Node initialized\')\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan data"""\r\n        # Process laser scan to reduce dimensionality\r\n        ranges = np.array(msg.ranges)\r\n        ranges = np.nan_to_num(ranges, nan=np.inf)  # Replace NaN with infinity\r\n\r\n        # Reduce to 36 readings for computational efficiency\r\n        step = len(ranges) // 36\r\n        self.current_scan = ranges[::step][:36]\r\n\r\n    def odom_callback(self, msg):\r\n        """Process odometry data"""\r\n        self.current_odom = msg\r\n\r\n    def get_state(self):\r\n        """Get current state for the RL agent"""\r\n        if self.current_scan is None or self.current_odom is None:\r\n            return None\r\n\r\n        # Get robot position and orientation\r\n        pos = self.current_odom.pose.pose.position\r\n        current_pos = np.array([pos.x, pos.y])\r\n\r\n        # Get robot orientation\r\n        quat = self.current_odom.pose.pose.orientation\r\n        # Convert quaternion to euler (simplified - just get yaw)\r\n        # In a real implementation, you\'d use tf2 for proper conversion\r\n        yaw = self.quaternion_to_yaw(quat)\r\n\r\n        # Calculate relative target position\r\n        relative_target = self.target_position - current_pos\r\n\r\n        # Combine laser scan and relative target position\r\n        state = np.concatenate([self.current_scan / 10.0, relative_target, [yaw]])\r\n\r\n        return state\r\n\r\n    def quaternion_to_yaw(self, quat):\r\n        """Convert quaternion to yaw angle (simplified)"""\r\n        # This is a simplified conversion - in practice, use tf2\r\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\r\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\r\n        return np.arctan2(siny_cosp, cosy_cosp)\r\n\r\n    def select_action(self, state):\r\n        """Select action using epsilon-greedy policy"""\r\n        if np.random.random() <= self.epsilon:\r\n            return random.randrange(self.action_dim)\r\n\r\n        state_tensor = torch.FloatTensor(state).unsqueeze(0)\r\n        q_values = self.q_network(state_tensor)\r\n        return np.argmax(q_values.cpu().data.numpy())\r\n\r\n    def calculate_reward(self, state, action, next_state):\r\n        """Calculate reward based on state transition"""\r\n        # Get current and next positions\r\n        current_pos = np.array([state[-3], state[-2]])  # x, y from state\r\n        next_pos = np.array([next_state[-3], next_state[-2]])\r\n\r\n        # Distance to target\r\n        current_dist = np.linalg.norm(self.target_position - current_pos)\r\n        next_dist = np.linalg.norm(self.target_position - next_pos)\r\n\r\n        # Reward based on progress toward target\r\n        progress_reward = current_dist - next_dist\r\n\r\n        # Penalty for getting too close to obstacles\r\n        min_scan = np.min(state[:-3])  # Exclude position/orientation\r\n        obstacle_penalty = 0\r\n        if min_scan < 0.5:  # Too close to obstacle\r\n            obstacle_penalty = -1.0\r\n\r\n        # Large reward for reaching target\r\n        target_reward = 0\r\n        if next_dist < 0.5:  # Within 0.5m of target\r\n            target_reward = 100.0\r\n\r\n        # Small penalty for each step (encourage efficiency)\r\n        step_penalty = -0.1\r\n\r\n        total_reward = progress_reward + obstacle_penalty + target_reward + step_penalty\r\n\r\n        return total_reward\r\n\r\n    def remember(self, state, action, reward, next_state, done):\r\n        """Store experience in replay buffer"""\r\n        self.memory.append((state, action, reward, next_state, done))\r\n\r\n    def replay(self):\r\n        """Train the network on a batch of experiences"""\r\n        if len(self.memory) < self.batch_size:\r\n            return\r\n\r\n        batch = random.sample(self.memory, self.batch_size)\r\n        states = torch.FloatTensor([e[0] for e in batch])\r\n        actions = torch.LongTensor([e[1] for e in batch])\r\n        rewards = torch.FloatTensor([e[2] for e in batch])\r\n        next_states = torch.FloatTensor([e[3] for e in batch])\r\n        dones = torch.BoolTensor([e[4] for e in batch])\r\n\r\n        current_q_values = self.q_network(states).gather(1, actions.unsqueeze(1))\r\n        next_q_values = self.target_network(next_states).max(1)[0].detach()\r\n        target_q_values = rewards + (self.gamma * next_q_values * ~dones)\r\n\r\n        loss = nn.MSELoss()(current_q_values.squeeze(), target_q_values)\r\n\r\n        self.optimizer.zero_grad()\r\n        loss.backward()\r\n        self.optimizer.step()\r\n\r\n        if self.epsilon > self.epsilon_min:\r\n            self.epsilon *= self.epsilon_decay\r\n\r\n    def navigation_loop(self):\r\n        """Main navigation loop"""\r\n        state = self.get_state()\r\n        if state is None:\r\n            return\r\n\r\n        # Select action\r\n        action = self.select_action(state)\r\n\r\n        # Execute action\r\n        cmd_vel = Twist()\r\n        if action == 0:  # Forward\r\n            cmd_vel.linear.x = 0.5\r\n            cmd_vel.angular.z = 0.0\r\n        elif action == 1:  # Turn left\r\n            cmd_vel.linear.x = 0.2\r\n            cmd_vel.angular.z = 0.5\r\n        elif action == 2:  # Turn right\r\n            cmd_vel.linear.x = 0.2\r\n            cmd_vel.angular.z = -0.5\r\n        elif action == 3:  # Stop\r\n            cmd_vel.linear.x = 0.0\r\n            cmd_vel.angular.z = 0.0\r\n\r\n        # Publish command\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n        # Update network with experience\r\n        next_state = self.get_state()\r\n        if next_state is not None:\r\n            reward = self.calculate_reward(state, action, next_state)\r\n            done = np.linalg.norm(self.target_position - np.array([next_state[-3], next_state[-2]])) < 0.5\r\n            self.remember(state, action, reward, next_state, done)\r\n            self.replay()\r\n\r\n    def update_target_network(self):\r\n        """Update target network with current network weights"""\r\n        self.target_network.load_state_dict(self.q_network.state_dict())\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = NavigationNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-5-create-the-manipulation-node",children:"Step 5: Create the Manipulation Node"}),"\n",(0,i.jsxs)(n.p,{children:["Create the manipulation node in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/ai_robot_system/manipulation_node.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\n"""\r\nAI Manipulation Node\r\nImplements robotic arm control and grasping using AI techniques\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom geometry_msgs.msg import Pose, Point, Quaternion\r\nfrom std_msgs.msg import Float64MultiArray\r\nfrom vision_msgs.msg import Detection2DArray\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\nimport numpy as np\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.optim as optim\r\nfrom scipy.spatial.transform import Rotation as R\r\nimport time\r\n\r\n\r\nclass GraspNet(nn.Module):\r\n    def __init__(self, state_dim, action_dim, hidden_dim=256):\r\n        super(GraspNet, self).__init__()\r\n\r\n        self.network = nn.Sequential(\r\n            nn.Linear(state_dim, hidden_dim),\r\n            nn.ReLU(),\r\n            nn.Linear(hidden_dim, hidden_dim),\r\n            nn.ReLU(),\r\n            nn.Linear(hidden_dim, hidden_dim),\r\n            nn.ReLU(),\r\n            nn.Linear(hidden_dim, action_dim)\r\n        )\r\n\r\n    def forward(self, state):\r\n        return torch.tanh(self.network(state))\r\n\r\n\r\nclass ManipulationNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'manipulation_node\')\r\n\r\n        # Initialize grasp network\r\n        self.state_dim = 7 + 3 + 4  # joint states (7) + object position (3) + object orientation (4)\r\n        self.action_dim = 7  # 7 joint positions for the arm\r\n        self.grasp_net = GraspNet(self.state_dim, self.action_dim)\r\n\r\n        # Current states\r\n        self.current_joints = None\r\n        self.detected_objects = []\r\n        self.target_object = None\r\n\r\n        # Create subscribers\r\n        self.joint_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10\r\n        )\r\n\r\n        self.detection_sub = self.create_subscription(\r\n            Detection2DArray, \'/ai_robot/detections\', self.detection_callback, 10\r\n        )\r\n\r\n        # Create publishers\r\n        self.joint_cmd_pub = self.create_publisher(\r\n            Float64MultiArray, \'/joint_group_position_controller/commands\', 10\r\n        )\r\n\r\n        # Create timer for manipulation loop\r\n        self.manip_timer = self.create_timer(0.1, self.manipulation_loop)\r\n\r\n        # Initialize TF\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        self.get_logger().info(\'AI Manipulation Node initialized\')\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Process joint state messages"""\r\n        self.current_joints = np.array(msg.position)\r\n\r\n    def detection_callback(self, msg):\r\n        """Process object detection messages"""\r\n        self.detected_objects = []\r\n\r\n        for detection in msg.detections:\r\n            if len(detection.results) > 0:\r\n                result = detection.results[0]\r\n                obj = {\r\n                    \'class\': result.hypothesis.class_id,\r\n                    \'confidence\': result.hypothesis.score,\r\n                    \'position\': detection.bbox.center  # This is image center, need to convert to 3D\r\n                }\r\n                self.detected_objects.append(obj)\r\n\r\n    def convert_image_to_3d(self, image_point, depth):\r\n        """Convert 2D image coordinates to 3D world coordinates"""\r\n        # This is a simplified conversion - in practice, you\'d use camera calibration\r\n        # For this example, we\'ll assume a fixed conversion\r\n        if depth is None:\r\n            depth = 1.0  # Default depth if not available\r\n\r\n        # Simplified conversion (would use camera matrix in real implementation)\r\n        x_3d = (image_point.x - 320) * depth / 640  # Assuming 640x480 image\r\n        y_3d = (image_point.y - 240) * depth / 480\r\n        z_3d = depth\r\n\r\n        return np.array([x_3d, y_3d, z_3d])\r\n\r\n    def select_target_object(self):\r\n        """Select the most promising object for manipulation"""\r\n        if not self.detected_objects:\r\n            return None\r\n\r\n        # For this example, select the object with highest confidence\r\n        best_obj = max(self.detected_objects, key=lambda x: x[\'confidence\'])\r\n\r\n        # Convert 2D position to 3D (simplified)\r\n        # In a real implementation, you\'d use depth information\r\n        obj_3d_pos = self.convert_image_to_3d(best_obj[\'position\'], None)\r\n\r\n        return {\r\n            \'class\': best_obj[\'class\'],\r\n            \'confidence\': best_obj[\'confidence\'],\r\n            \'position\': obj_3d_pos\r\n        }\r\n\r\n    def plan_grasp(self, object_pos):\r\n        """Plan a grasp for the target object"""\r\n        if self.current_joints is None:\r\n            return None\r\n\r\n        # Simplified grasp planning\r\n        # In a real implementation, you\'d use inverse kinematics and grasp planning algorithms\r\n\r\n        # Calculate desired end-effector position (slightly above object)\r\n        grasp_pos = object_pos.copy()\r\n        grasp_pos[2] += 0.2  # Approach from above\r\n\r\n        # Define grasp orientation (pointing down)\r\n        grasp_orientation = [0, 0, 0, 1]  # Quaternion for downward orientation\r\n\r\n        # Plan joint positions to reach this pose\r\n        # This is a simplified approach - real implementation would use IK\r\n        desired_joints = self.plan_arm_motion_to_pose(grasp_pos, grasp_orientation)\r\n\r\n        return desired_joints\r\n\r\n    def plan_arm_motion_to_pose(self, target_pos, target_orientation):\r\n        """Plan arm motion to reach target pose (simplified)"""\r\n        if self.current_joints is None:\r\n            return np.zeros(7)\r\n\r\n        # This is a very simplified approach\r\n        # In practice, you\'d use inverse kinematics (IK) solvers\r\n\r\n        # For this example, we\'ll just return a simple motion plan\r\n        # that moves the arm toward the target\r\n        current_pos = self.get_end_effector_position()\r\n\r\n        # Calculate motion direction\r\n        direction = target_pos - current_pos\r\n        step_size = 0.1  # Move in 10cm steps\r\n\r\n        # This is a placeholder - real implementation would use proper IK\r\n        desired_joints = self.current_joints.copy()\r\n\r\n        # Simple joint adjustments based on target position\r\n        # This is highly simplified and would not work in practice\r\n        desired_joints[0] += np.arctan2(target_pos[1], target_pos[0]) * 0.1  # Base joint\r\n        desired_joints[1] += (target_pos[2] - current_pos[2]) * 0.5  # Shoulder joint\r\n        desired_joints[2] += (target_pos[0] - current_pos[0]) * 0.2  # Elbow joint\r\n\r\n        # Constrain joint limits\r\n        joint_limits = [\r\n            [-2.967, 2.967],   # Joint 1\r\n            [-1.832, 1.832],   # Joint 2\r\n            [-2.618, 2.618],   # Joint 3\r\n            [-3.141, 3.141],   # Joint 4\r\n            [-2.967, 2.967],   # Joint 5\r\n            [-3.141, 3.141],   # Joint 6\r\n            [-2.967, 2.967]    # Joint 7\r\n        ]\r\n\r\n        for i, (min_limit, max_limit) in enumerate(joint_limits):\r\n            desired_joints[i] = np.clip(desired_joints[i], min_limit, max_limit)\r\n\r\n        return desired_joints\r\n\r\n    def get_end_effector_position(self):\r\n        """Get current end-effector position (simplified)"""\r\n        # This is a simplified forward kinematics calculation\r\n        # In practice, you\'d use a proper FK solver\r\n        if self.current_joints is None:\r\n            return np.array([0, 0, 0.5])  # Default position\r\n\r\n        # Simplified calculation based on joint angles\r\n        # This is not accurate and just for demonstration\r\n        q = self.current_joints\r\n\r\n        # Base position\r\n        x = 0.1  # Offset from base\r\n        y = 0\r\n        z = 0.1  # Base height\r\n\r\n        # Add contributions from each joint\r\n        # This is a very simplified approximation\r\n        for i, angle in enumerate(q[:3]):  # Consider first 3 joints\r\n            radius = 0.1 * (i + 1)  # Simplified link length\r\n            x += radius * np.cos(sum(q[:i+1]))\r\n            y += radius * np.sin(sum(q[:i+1]))\r\n            z += 0.05  # Height contribution\r\n\r\n        return np.array([x, y, z])\r\n\r\n    def execute_grasp(self, grasp_joints):\r\n        """Execute the planned grasp"""\r\n        if grasp_joints is None:\r\n            return False\r\n\r\n        # Create joint command message\r\n        cmd_msg = Float64MultiArray()\r\n        cmd_msg.data = grasp_joints.tolist()\r\n\r\n        # Publish command\r\n        self.joint_cmd_pub.publish(cmd_msg)\r\n\r\n        self.get_logger().info(f\'Executing grasp with joints: {grasp_joints}\')\r\n        return True\r\n\r\n    def manipulation_loop(self):\r\n        """Main manipulation loop"""\r\n        # Select target object\r\n        self.target_object = self.select_target_object()\r\n\r\n        if self.target_object is not None:\r\n            self.get_logger().info(f\'Target object: {self.target_object["class"]} at {self.target_object["position"]}\')\r\n\r\n            # Plan grasp\r\n            grasp_joints = self.plan_grasp(self.target_object[\'position\'])\r\n\r\n            if grasp_joints is not None:\r\n                # Execute grasp\r\n                success = self.execute_grasp(grasp_joints)\r\n\r\n                if success:\r\n                    self.get_logger().info(\'Grasp executed successfully\')\r\n                else:\r\n                    self.get_logger().warn(\'Failed to execute grasp\')\r\n            else:\r\n                self.get_logger().warn(\'Could not plan grasp for target object\')\r\n        else:\r\n            self.get_logger().info(\'No objects detected for manipulation\')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ManipulationNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-6-create-the-main-control-node",children:"Step 6: Create the Main Control Node"}),"\n",(0,i.jsxs)(n.p,{children:["Create the main control node in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/ai_robot_system/ai_robot_controller.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\n\"\"\"\r\nAI Robot Main Controller\r\nCoordinates perception, navigation, and manipulation modules\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Pose, Twist\r\nfrom sensor_msgs.msg import JointState\r\nfrom vision_msgs.msg import Detection2DArray\r\nfrom ai_robot_system.perception_node import AI PerceptionNode\r\nfrom ai_robot_system.navigation_node import NavigationNode\r\nfrom ai_robot_system.manipulation_node import ManipulationNode\r\nimport time\r\nimport threading\r\n\r\n\r\nclass AIRobotController(Node):\r\n    def __init__(self):\r\n        super().__init__('ai_robot_controller')\r\n\r\n        # Initialize component nodes\r\n        self.perception_node = AI PerceptionNode()\r\n        self.navigation_node = NavigationNode()\r\n        self.manipulation_node = ManipulationNode()\r\n\r\n        # Create state machine\r\n        self.current_state = \"IDLE\"  # IDLE, NAVIGATING, MANIPULATING, PERCEIVING\r\n        self.task_queue = []\r\n        self.robot_tasks = {\r\n            'explore': self.explore_environment,\r\n            'find_object': self.find_object_task,\r\n            'navigate_to_object': self.navigate_to_object_task,\r\n            'grasp_object': self.grasp_object_task,\r\n            'place_object': self.place_object_task\r\n        }\r\n\r\n        # Create publisher for state updates\r\n        self.state_pub = self.create_publisher(String, '/ai_robot/state', 10)\r\n\r\n        # Create timer for main control loop\r\n        self.control_timer = self.create_timer(1.0, self.control_loop)\r\n\r\n        self.get_logger().info('AI Robot Controller initialized')\r\n\r\n    def control_loop(self):\r\n        \"\"\"Main control loop\"\"\"\r\n        # Publish current state\r\n        state_msg = String()\r\n        state_msg.data = self.current_state\r\n        self.state_pub.publish(state_msg)\r\n\r\n        # Process task queue\r\n        if self.task_queue:\r\n            next_task = self.task_queue[0]\r\n            self.execute_task(next_task)\r\n        else:\r\n            # Default behavior when no tasks\r\n            self.current_state = \"IDLE\"\r\n            self.idle_behavior()\r\n\r\n    def execute_task(self, task):\r\n        \"\"\"Execute a specific task\"\"\"\r\n        if task in self.robot_tasks:\r\n            self.get_logger().info(f'Executing task: {task}')\r\n            self.current_state = task.upper()\r\n            success = self.robot_tasks[task]()\r\n\r\n            if success:\r\n                # Remove completed task\r\n                self.task_queue.pop(0)\r\n                self.get_logger().info(f'Task {task} completed successfully')\r\n            else:\r\n                self.get_logger().warn(f'Task {task} failed')\r\n        else:\r\n            self.get_logger().error(f'Unknown task: {task}')\r\n            self.task_queue.pop(0)  # Remove invalid task\r\n\r\n    def add_task(self, task):\r\n        \"\"\"Add a task to the queue\"\"\"\r\n        self.task_queue.append(task)\r\n        self.get_logger().info(f'Task {task} added to queue')\r\n\r\n    def idle_behavior(self):\r\n        \"\"\"Behavior when robot is idle\"\"\"\r\n        # For now, just stay still\r\n        # In a real implementation, you might have the robot patrol or charge\r\n        pass\r\n\r\n    def explore_environment(self):\r\n        \"\"\"Explore the environment\"\"\"\r\n        self.get_logger().info('Exploring environment...')\r\n\r\n        # This would involve moving to various locations to build a map\r\n        # For this example, we'll just move in a simple pattern\r\n        self.navigation_node.target_position = [2.0, 2.0]\r\n        time.sleep(5)  # Simulate exploration time\r\n\r\n        self.navigation_node.target_position = [-2.0, 2.0]\r\n        time.sleep(5)\r\n\r\n        self.navigation_node.target_position = [0.0, 0.0]  # Return to start\r\n        time.sleep(5)\r\n\r\n        return True\r\n\r\n    def find_object_task(self):\r\n        \"\"\"Find a specific object in the environment\"\"\"\r\n        self.get_logger().info('Searching for objects...')\r\n\r\n        # Wait for object detections\r\n        timeout = time.time() + 60*2  # 2 minutes timeout\r\n        while time.time() < timeout:\r\n            if self.perception_node.current_scan is not None:\r\n                # Check if any objects were detected\r\n                if self.perception_node.detection_pub.get_subscription_count() > 0:\r\n                    # In a real implementation, you'd check the actual detections\r\n                    # For this example, we'll assume an object was found\r\n                    self.get_logger().info('Object found!')\r\n                    return True\r\n            time.sleep(0.1)\r\n\r\n        self.get_logger().warn('Object not found within timeout')\r\n        return False\r\n\r\n    def navigate_to_object_task(self):\r\n        \"\"\"Navigate to a detected object\"\"\"\r\n        self.get_logger().info('Navigating to object...')\r\n\r\n        # In a real implementation, you'd use the object's position\r\n        # For this example, we'll navigate to a fixed location\r\n        self.navigation_node.target_position = [1.0, 1.0]\r\n\r\n        # Wait until navigation is complete\r\n        timeout = time.time() + 60  # 1 minute timeout\r\n        while time.time() < timeout:\r\n            # Check if robot is close to target\r\n            if self.navigation_node.current_odom is not None:\r\n                pos = self.navigation_node.current_odom.pose.pose.position\r\n                current_pos = np.array([pos.x, pos.y])\r\n                dist = np.linalg.norm(self.navigation_node.target_position - current_pos)\r\n\r\n                if dist < 0.5:  # Within 0.5m of target\r\n                    self.get_logger().info('Navigation to object completed')\r\n                    return True\r\n            time.sleep(0.1)\r\n\r\n        self.get_logger().warn('Navigation to object failed')\r\n        return False\r\n\r\n    def grasp_object_task(self):\r\n        \"\"\"Grasp a nearby object\"\"\"\r\n        self.get_logger().info('Attempting to grasp object...')\r\n\r\n        # In a real implementation, you'd coordinate with perception and manipulation\r\n        # For this example, we'll just execute a simple grasp motion\r\n        if self.manipulation_node.current_joints is not None:\r\n            # Plan a simple grasp motion\r\n            grasp_joints = self.manipulation_node.current_joints.copy()\r\n            # Move to a pre-defined grasp position\r\n            grasp_joints[0] = 0.5  # Base joint\r\n            grasp_joints[1] = 0.3  # Shoulder joint\r\n            grasp_joints[2] = -0.2  # Elbow joint\r\n\r\n            self.manipulation_node.execute_grasp(grasp_joints)\r\n            time.sleep(3)  # Wait for grasp to complete\r\n\r\n            # Close gripper (simplified)\r\n            # In a real implementation, you'd control the gripper separately\r\n            self.get_logger().info('Grasp attempt completed')\r\n            return True\r\n\r\n        self.get_logger().warn('Cannot execute grasp - no joint information available')\r\n        return False\r\n\r\n    def place_object_task(self):\r\n        \"\"\"Place the grasped object at a location\"\"\"\r\n        self.get_logger().info('Placing object...')\r\n\r\n        # Move to placement location\r\n        self.navigation_node.target_position = [3.0, 0.0]\r\n\r\n        # Wait for navigation to complete\r\n        timeout = time.time() + 60  # 1 minute timeout\r\n        while time.time() < timeout:\r\n            if self.navigation_node.current_odom is not None:\r\n                pos = self.navigation_node.current_odom.pose.pose.position\r\n                current_pos = np.array([pos.x, pos.y])\r\n                dist = np.linalg.norm(self.navigation_node.target_position - current_pos)\r\n\r\n                if dist < 0.5:\r\n                    # Open gripper to place object (simplified)\r\n                    # In a real implementation, you'd control the gripper separately\r\n                    self.get_logger().info('Object placed successfully')\r\n                    return True\r\n            time.sleep(0.1)\r\n\r\n        self.get_logger().warn('Object placement failed')\r\n        return False\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = AIRobotController()\r\n\r\n    # Add some sample tasks to the queue\r\n    controller.add_task('explore')\r\n    controller.add_task('find_object')\r\n    controller.add_task('navigate_to_object')\r\n    controller.add_task('grasp_object')\r\n    controller.add_task('place_object')\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-7-create-launch-files",children:"Step 7: Create Launch Files"}),"\n",(0,i.jsxs)(n.p,{children:["Create the main launch file in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/launch/ai_robot_system.launch.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\n\r\ndef generate_launch_description():\r\n    # Package directory\r\n    pkg_dir = get_package_share_directory('ai_robot_system')\r\n\r\n    # Launch arguments\r\n    use_sim_time = DeclareLaunchArgument(\r\n        'use_sim_time',\r\n        default_value='true',\r\n        description='Use simulation (Gazebo) clock if true'\r\n    )\r\n\r\n    # Launch Gazebo simulation (if available)\r\n    # This would typically be a separate launch file, but we'll include it here\r\n    # For this example, we'll assume a separate Gazebo launch is handled externally\r\n\r\n    # AI Perception Node\r\n    perception_node = Node(\r\n        package='ai_robot_system',\r\n        executable='perception_node',\r\n        name='ai_perception_node',\r\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        output='screen'\r\n    )\r\n\r\n    # AI Navigation Node\r\n    navigation_node = Node(\r\n        package='ai_robot_system',\r\n        executable='navigation_node',\r\n        name='ai_navigation_node',\r\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        output='screen'\r\n    )\r\n\r\n    # AI Manipulation Node\r\n    manipulation_node = Node(\r\n        package='ai_robot_system',\r\n        executable='manipulation_node',\r\n        name='ai_manipulation_node',\r\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        output='screen'\r\n    )\r\n\r\n    # AI Robot Controller Node\r\n    controller_node = Node(\r\n        package='ai_robot_system',\r\n        executable='ai_robot_controller',\r\n        name='ai_robot_controller',\r\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        output='screen'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        use_sim_time,\r\n        perception_node,\r\n        navigation_node,\r\n        manipulation_node,\r\n        controller_node\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-8-update-setuppy",children:"Step 8: Update setup.py"}),"\n",(0,i.jsxs)(n.p,{children:["Update the ",(0,i.jsx)(n.code,{children:"setup.py"})," file in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/setup.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\r\n\r\npackage_name = 'ai_robot_system'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.0.0',\r\n    packages=[package_name],\r\n    data_files=[\r\n        ('share/ament_index/resource_index/packages',\r\n            ['resource/' + package_name]),\r\n        ('share/' + package_name, ['package.xml']),\r\n        ('share/' + package_name + '/launch', ['launch/ai_robot_system.launch.py']),\r\n        ('share/' + package_name + '/models', ['models/ai_robot.urdf']),\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='Your Name',\r\n    maintainer_email='your.email@example.com',\r\n    description='AI-powered robot system using NVIDIA Isaac Platform',\r\n    license='Apache License 2.0',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'perception_node = ai_robot_system.perception_node:main',\r\n            'navigation_node = ai_robot_system.navigation_node:main',\r\n            'manipulation_node = ai_robot_system.manipulation_node:main',\r\n            'ai_robot_controller = ai_robot_system.ai_robot_controller:main',\r\n        ],\r\n    },\r\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-9-create-a-simulation-environment",children:"Step 9: Create a Simulation Environment"}),"\n",(0,i.jsxs)(n.p,{children:["Create a simple world file for Gazebo in ",(0,i.jsx)(n.code,{children:"~/isaac_ai_robot_ws/src/ai_robot_system/worlds/ai_robot_world.world"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.7">\r\n  <world name="ai_robot_world">\r\n    \x3c!-- Include ground plane --\x3e\r\n    <include>\r\n      <uri>model://ground_plane</uri>\r\n    </include>\r\n\r\n    \x3c!-- Include sun --\x3e\r\n    <include>\r\n      <uri>model://sun</uri>\r\n    </include>\r\n\r\n    \x3c!-- Add some objects for the robot to interact with --\x3e\r\n    <model name="red_box">\r\n      <pose>2 2 0.1 0 0 0</pose>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <box>\r\n              <size>0.2 0.2 0.2</size>\r\n            </box>\r\n          </geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <box>\r\n              <size>0.2 0.2 0.2</size>\r\n            </box>\r\n          </geometry>\r\n          <material>\r\n            <ambient>1 0 0 1</ambient>\r\n            <diffuse>1 0 0 1</diffuse>\r\n          </material>\r\n        </visual>\r\n        <inertial>\r\n          <mass>0.5</mass>\r\n          <inertia>\r\n            <ixx>0.0017</ixx>\r\n            <ixy>0</ixy>\r\n            <ixz>0</ixz>\r\n            <iyy>0.0017</iyy>\r\n            <iyz>0</iyz>\r\n            <izz>0.0017</izz>\r\n          </inertia>\r\n        </inertial>\r\n      </link>\r\n    </model>\r\n\r\n    <model name="blue_cylinder">\r\n      <pose>-2 -1 0.15 0 0 0</pose>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <cylinder>\r\n              <radius>0.1</radius>\r\n              <length>0.3</length>\r\n            </cylinder>\r\n          </geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <cylinder>\r\n              <radius>0.1</radius>\r\n              <length>0.3</length>\r\n            </cylinder>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0 0 1 1</ambient>\r\n            <diffuse>0 0 1 1</diffuse>\r\n          </material>\r\n        </visual>\r\n        <inertial>\r\n          <mass>0.3</mass>\r\n          <inertia>\r\n            <ixx>0.0015</ixx>\r\n            <ixy>0</ixy>\r\n            <ixz>0</ixz>\r\n            <iyy>0.0015</iyy>\r\n            <iyz>0</iyz>\r\n            <izz>0.001</izz>\r\n          </inertia>\r\n        </inertial>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Physics configuration --\x3e\r\n    <physics type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1</real_time_factor>\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n    </physics>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"step-10-build-and-run-the-system",children:"Step 10: Build and Run the System"}),"\n",(0,i.jsx)(n.p,{children:"Build your package:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/isaac_ai_robot_ws\r\ncolcon build --packages-select ai_robot_system\r\nsource install/setup.bash\n"})}),"\n",(0,i.jsx)(n.p,{children:"Run the complete AI robot system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Launch the robot system\r\nros2 launch ai_robot_system ai_robot_system.launch.py\r\n\r\n# Terminal 2: (Optional) Launch Gazebo simulation with your robot\r\n# This would depend on your specific Gazebo setup\n"})}),"\n",(0,i.jsx)(n.h2,{id:"step-11-testing-and-validation",children:"Step 11: Testing and Validation"}),"\n",(0,i.jsx)(n.p,{children:"Test the system by sending commands and monitoring the behavior:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Monitor robot state\r\nros2 topic echo /ai_robot/state\r\n\r\n# Monitor detections\r\nros2 topic echo /ai_robot/detections\r\n\r\n# Monitor navigation commands\r\nros2 topic echo /cmd_vel\r\n\r\n# Send manual navigation commands if needed\r\nros2 topic pub /cmd_vel geometry_msgs/msg/Twist '{linear: {x: 0.5}, angular: {z: 0.2}}'\n"})}),"\n",(0,i.jsx)(n.h2,{id:"expected-results",children:"Expected Results"}),"\n",(0,i.jsx)(n.p,{children:"When you run the complete AI robot system:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The perception node should detect objects in the environment"}),"\n",(0,i.jsx)(n.li,{children:"The navigation node should plan paths to navigate to objects"}),"\n",(0,i.jsx)(n.li,{children:"The manipulation node should plan and execute grasping motions"}),"\n",(0,i.jsx)(n.li,{children:"The main controller should coordinate all modules to perform complex tasks"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.p,{children:"If you encounter issues:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Missing dependencies"}),": Install required Python packages:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pip3 install torch torchvision opencv-python tf2_ros\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CUDA issues"}),": Ensure your NVIDIA drivers and CUDA are properly installed"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ROS 2 topics not connecting"}),": Check that all nodes are using the same ROS domain ID"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance issues"}),": The AI models may be computationally intensive; ensure your GPU can handle the workload"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,i.jsx)(n.p,{children:"To extend this system:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add more sophisticated AI models"}),": Replace the simple models with more advanced ones"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement learning algorithms"}),": Add reinforcement learning for improved navigation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add more sensors"}),": Include depth cameras, IMUs, or other sensors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Improve manipulation"}),": Add grasp planning and force control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add semantic mapping"}),": Create maps with object labels and relationships"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"In this lab, you have created a complete AI-powered robot system that integrates:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Perception using computer vision and AI"}),"\n",(0,i.jsx)(n.li,{children:"Navigation using reinforcement learning"}),"\n",(0,i.jsx)(n.li,{children:"Manipulation using AI-based grasp planning"}),"\n",(0,i.jsx)(n.li,{children:"High-level task coordination"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This system demonstrates the power of the NVIDIA Isaac Platform for creating sophisticated AI-powered robotic applications that can perceive, navigate, and manipulate in their environment."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);